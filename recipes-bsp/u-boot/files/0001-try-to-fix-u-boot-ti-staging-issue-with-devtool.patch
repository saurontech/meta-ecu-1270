From e56315925540a96561ed6d1618792082461336e3 Mon Sep 17 00:00:00 2001
From: Samuel Cheng <samuelogre@gmail.com>
Date: Fri, 19 Sep 2025 15:56:37 +0800
Subject: [PATCH] try to fix u-boot-ti-staging issue with devtool

---
 arch/arm/dts/k3-j722s-evm.dts   | 360 +++++++++++++-------------------
 board/ti/j722s/Kconfig          |  31 ++-
 board/ti/j722s/evm.c            |  42 +---
 common/autoboot.c               | 330 +++++++++++++++++++++++++++++
 configs/j722s_evm_a53_defconfig |  12 ++
 include/configs/j722s_evm.h     |  99 +++++++++
 6 files changed, 611 insertions(+), 263 deletions(-)

diff --git a/arch/arm/dts/k3-j722s-evm.dts b/arch/arm/dts/k3-j722s-evm.dts
index d799be55492..38360bed89f 100644
--- a/arch/arm/dts/k3-j722s-evm.dts
+++ b/arch/arm/dts/k3-j722s-evm.dts
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only OR MIT
 /*
- * Device Tree file for the J722S EVM
+ * Device Tree file for the J722S ECU1270
  * Copyright (C) 2024 Texas Instruments Incorporated - https://www.ti.com/
  *
  * Schematics: https://www.ti.com/lit/zip/sprr495
@@ -15,16 +15,21 @@
 #include "k3-serdes.h"
 
 / {
-	compatible = "ti,j722s-evm", "ti,j722s";
-	model = "Texas Instruments J722S EVM";
+	compatible = "ti,j722s-evm", "ti,j722s";
+	model = "Texas Instruments J722S ECU1270";
 
 	aliases {
 		serial0 = &wkup_uart0;
 		serial2 = &main_uart0;
+        i2c0 = &main_i2c0;
+        i2c1 = &wkup_i2c0;
+        i2c3 = &main_i2c3;
 		mmc0 = &sdhci0;
 		mmc1 = &sdhci1;
 		usb0 = &usb0;
 		usb1 = &usb1;
+		gpio0 = &main_gpio0;
+		gpio1 = &main_gpio1;
 	};
 
 	chosen {
@@ -32,9 +37,9 @@
 	};
 
 	memory@80000000 {
-		/* 8G RAM */
+		/* 4G RAM */
 		reg = <0x00000000 0x80000000 0x00000000 0x80000000>,
-		      <0x00000008 0x80000000 0x00000001 0x80000000>;
+		      <0x00000008 0x80000000 0x00000000 0x80000000>;
 		device_type = "memory";
 		bootph-all;
 	};
@@ -115,7 +120,8 @@
 		};
 
 		rtos_ipc_memory_region: ipc-memories@a5000000 {
-			reg = <0x00 0xa5000000 0x00 0x1c00000>;
+			reg = <0x00 0xa5000000 0x00 0x00800000>; // 2G
+			//reg = <0x00 0xa5000000 0x00 0x1c00000>; // 4G
 			alignment = <0x1000>;
 			no-map;
 		};
@@ -150,8 +156,6 @@
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
 		regulator-boot-on;
-		enable-active-high;
-		gpio = <&exp1 15 GPIO_ACTIVE_HIGH>;
 		bootph-all;
 	};
 
@@ -164,7 +168,7 @@
 		regulator-max-microvolt = <3300000>;
 		regulator-boot-on;
 		vin-supply = <&vsys_5v0>;
-		gpios = <&main_gpio0 70 GPIO_ACTIVE_HIGH>;
+		gpios = <&main_gpio1 49 GPIO_ACTIVE_HIGH>;
 		states = <1800000 0x0>,
 			 <3300000 0x1>;
 	};
@@ -186,6 +190,12 @@
 		regulator-always-on;
 		regulator-boot-on;
 	};
+
+	gpio_id: gpio-id {
+		compatible = "gpio-id";
+		gpio-id0 = <&main_gpio1 13 GPIO_ACTIVE_HIGH>;
+		bootph-all;
+	};
 };
 
 &main_pmx0 {
@@ -198,17 +208,25 @@
 		bootph-all;
 	};
 
+	main_i2c3_pins_default: main-i2c3-default-pins {
+		pinctrl-single,pins = <
+			J722S_IOPAD(0x0118, PIN_INPUT_PULLUP, 6) /* (H26) MMC2_CLK.I2C3_SCL */
+			J722S_IOPAD(0x0120, PIN_INPUT_PULLUP, 6) /* (F27) MMC2_CMD.I2C3_SDA */
+		>;
+		bootph-all;
+	};
+
 	main_uart0_pins_default: main-uart0-default-pins {
 		pinctrl-single,pins = <
-			J722S_IOPAD(0x01c8, PIN_INPUT, 0)	/* (A22) UART0_RXD */
-			J722S_IOPAD(0x01cc, PIN_OUTPUT, 0)	/* (B22) UART0_TXD */
+			J722S_IOPAD(0x01c8, PIN_INPUT, 0)	/* (F19) UART0_RXD */
+			J722S_IOPAD(0x01cc, PIN_OUTPUT, 0)	/* (F20) UART0_TXD */
 		>;
 		bootph-all;
 	};
 
 	vdd_sd_dv_pins_default: vdd-sd-dv-default-pins {
 		pinctrl-single,pins = <
-			J722S_IOPAD(0x0120, PIN_INPUT, 7) /* (F27) MMC2_CMD.GPIO0_70 */
+			J722S_IOPAD(0x0244, PIN_OUTPUT, 7) /* (A24) MMC1_SDWP.GPIO1_49 */
 		>;
 		bootph-all;
 	};
@@ -239,23 +257,6 @@
 		>;
 	};
 
-	ospi0_pins_default: ospi0-default-pins {
-		pinctrl-single,pins = <
-			J722S_IOPAD(0x0000, PIN_OUTPUT, 0) /* (L24) OSPI0_CLK */
-			J722S_IOPAD(0x002c, PIN_OUTPUT, 0) /* (K26) OSPI0_CSn0 */
-			J722S_IOPAD(0x000c, PIN_INPUT, 0) /* (K27) OSPI0_D0 */
-			J722S_IOPAD(0x0010, PIN_INPUT, 0) /* (L27) OSPI0_D1 */
-			J722S_IOPAD(0x0014, PIN_INPUT, 0) /* (L26) OSPI0_D2 */
-			J722S_IOPAD(0x0018, PIN_INPUT, 0) /* (L25) OSPI0_D3 */
-			J722S_IOPAD(0x001c, PIN_INPUT, 0) /* (L21) OSPI0_D4 */
-			J722S_IOPAD(0x0020, PIN_INPUT, 0) /* (M26) OSPI0_D5 */
-			J722S_IOPAD(0x0024, PIN_INPUT, 0) /* (N27) OSPI0_D6 */
-			J722S_IOPAD(0x0028, PIN_INPUT, 0) /* (M27) OSPI0_D7 */
-			J722S_IOPAD(0x0008, PIN_INPUT, 0) /* (L22) OSPI0_DQS */
-		>;
-		bootph-all;
-	};
-
 	rgmii1_pins_default: rgmii1-default-pins {
 		pinctrl-single,pins = <
 			J722S_IOPAD(0x014c, PIN_INPUT, 0) /* (AC25) RGMII1_RD0 */
@@ -272,38 +273,68 @@
 			J722S_IOPAD(0x012c, PIN_OUTPUT, 0) /* (AF25) RGMII1_TX_CTL */
 		>;
 	};
-};
 
-&cpsw3g {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&rgmii1_pins_default>;
-};
+	main_gpio0_pins_default: main-gpio0-default-pins {
+		pinctrl-single,pins = <
+			J722S_IOPAD(0x007c, PIN_OUTPUT_PULLUP, 7) /* (T23) GPMC0_CLK.GPIO0_31 GPIO6 DO2 */
+			J722S_IOPAD(0x0094, PIN_OUTPUT_PULLUP, 7) /* (P26) GPMC0_BE1n.GPIO0_36 GPIO7 DO3 */
 
-&cpsw3g_mdio {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&mdio_pins_default>;
+			// RECOVERY KEY
+			J722S_IOPAD(0x000c, PIN_INPUT, 7) /* (K27) OSPI0_D0.GPIO0_3 GPIO_RESETn */
 
-	cpsw3g_phy0: ethernet-phy@0 {
-		reg = <0>;
-		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
-		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
-		ti,min-output-impedance;
+			// BOARD ID
+			J722S_IOPAD(0x00b8, PIN_INPUT, 7) /* (W27) VOUT0_DATA0.GPIO0_45 BID0 */
+			J722S_IOPAD(0x00bc, PIN_INPUT, 7) /* (W25) VOUT0_DATA1.GPIO0_46 BID1 */
+
+			J722S_IOPAD(0x00cc, PIN_INPUT, 7) /* (W21) VOUT0_DATA5.GPIO0_50 BID2 */
+			J722S_IOPAD(0x00d0, PIN_INPUT, 7) /* (Y26) VOUT0_DATA6.GPIO0_51 BID3 */
+
+			// POWER ENABLE
+			J722S_IOPAD(0x0010, PIN_OUTPUT_PULLUP, 7) /* (L27) OSPI0_D1.GPIO0_4 COM_PWR_EN */
+			J722S_IOPAD(0x00d4, PIN_OUTPUT_PULLUP, 7) /* (Y27) VOUT0_DATA7.GPIO0_52 PWR_EN1 */
+			J722S_IOPAD(0x00c4, PIN_OUTPUT_PULLUP, 7) /* (W23) VOUT0_DATA3.GPIO0_48 PWR_EN2 */
+
+			// Reset_M.2
+			J722S_IOPAD(0x002c, PIN_INPUT, 7) /* (K26) OSPI0_CSn0.GPIO0_11 */
+
+			// PCIE_RSTN1
+			J722S_IOPAD(0x0028, PIN_INPUT, 7) /* (M27) OSPI0_D7.GPIO0_10 */
+		>;
 	};
-};
 
-&cpsw_port1 {
-	phy-mode = "rgmii-rxid";
-	phy-handle = <&cpsw3g_phy0>;
+	main_gpio1_pins_default: main-gpio1-default-pins {
+		pinctrl-single,pins = <
+			// RS232/485
+			J722S_IOPAD(0x01f0, PIN_INPUT_PULLDOWN, 7) /* (A23) EXT_REFCLK1.GPIO1_30 COM1_SEL H-232 L-485 */
+			J722S_IOPAD(0x01b0, PIN_INPUT_PULLDOWN, 7) /* (F24) MCASP0_ACLKR.GPIO1_14 COM2_SEL H-232 L-485 */
+
+			// BOARD ID
+			J722S_IOPAD(0x01a0, PIN_INPUT, 7) /* (F23) MCASP0_AXR0.GPIO1_10 */
+			J722S_IOPAD(0x019c, PIN_INPUT, 7) /* (B25) MCASP0_AXR1.GPIO1_9 */
+
+			// PWREN_M2
+			J722S_IOPAD(0x0194, PIN_INPUT, 7) /* (A25) MCASP0_AXR3.GPIO1_7 */
+
+			// MPCIE3V3_EN
+			J722S_IOPAD(0x01a8, PIN_INPUT, 7) /* (C26) MCASP0_AFSX.GPIO1_12 */
+		>;
+	};
 };
 
-&cpsw_port2 {
-	status = "disabled";
+&main_gpio0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&main_gpio0_pins_default>;
 };
 
 &main_gpio1 {
 	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&main_gpio1_pins_default>;
+};
+
+&mcu_gpio0 {
+	status = "disabled";
 };
 
 &main_uart0 {
@@ -327,8 +358,8 @@
 
 	wkup_i2c0_pins_default: wkup-i2c0-default-pins {
 		pinctrl-single,pins = <
-			J722S_MCU_IOPAD(0x04c, PIN_INPUT_PULLUP, 0)	/* (C7) WKUP_I2C0_SCL */
-			J722S_MCU_IOPAD(0x050, PIN_INPUT_PULLUP, 0)	/* (C6) WKUP_I2C1_SDA */
+			J722S_MCU_IOPAD(0x04c, PIN_INPUT_PULLUP, 0)	/* (B9) WKUP_I2C0_SCL */
+			J722S_MCU_IOPAD(0x050, PIN_INPUT_PULLUP, 0)	/* (D11) WKUP_I2C1_SDA */
 		>;
 		bootph-all;
 	};
@@ -356,146 +387,6 @@
 	clock-frequency = <400000>;
 	status = "okay";
 	bootph-all;
-
-	exp1: gpio@23 {
-		compatible = "ti,tca6424";
-		reg = <0x23>;
-		gpio-controller;
-		#gpio-cells = <2>;
-		gpio-line-names = "TRC_MUX_SEL", "OSPI/ONAND_MUX_SEL",
-				  "MCASP1_FET_SEL", "CTRL_PM_I2C_OE#",
-				  "CSI_VIO_SEL", "USB2.0_MUX_SEL",
-				  "CSI01_MUX_SEL_2", "CSI23_MUX_SEL_2",
-				  "LMK1_OE1", "LMK1_OE0",
-				  "LMK2_OE0", "LMK2_OE1",
-				  "GPIO_RGMII1_RST#", "GPIO_AUD_RSTn",
-				  "GPIO_eMMC_RSTn", "GPIO_uSD_PWR_EN",
-				  "USER_LED2", "MCAN0_STB",
-				  "PCIe0_1L_RC_RSTz", "PCIe0_1L_PRSNT#",
-				  "ENET1_EXP_SPARE2", "ENET1_EXP_PWRDN",
-				  "PD_I2ENET1_I2CMUX_SELC_IRQ", "ENET1_EXP_RESETZ";
-		bootph-all;
-	};
-};
-
-&ospi0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&ospi0_pins_default>;
-	status = "okay";
-
-	flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0x0>;
-		spi-tx-bus-width = <8>;
-		spi-rx-bus-width = <8>;
-		spi-max-frequency = <25000000>;
-		cdns,tshsl-ns = <60>;
-		cdns,tsd2d-ns = <60>;
-		cdns,tchsh-ns = <60>;
-		cdns,tslch-ns = <60>;
-		cdns,read-delay = <4>;
-		bootph-all;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "ospi.tiboot3";
-				reg = <0x00 0x80000>;
-			};
-
-			partition@80000 {
-				label = "ospi.tispl";
-				reg = <0x80000 0x200000>;
-			};
-
-			partition@280000 {
-				label = "ospi.u-boot";
-				reg = <0x280000 0x400000>;
-			};
-
-			partition@680000 {
-				label = "ospi.env";
-				reg = <0x680000 0x40000>;
-			};
-
-			partition@6c0000 {
-				label = "ospi.env.backup";
-				reg = <0x6c0000 0x40000>;
-			};
-
-			partition@800000 {
-				label = "ospi.rootfs";
-				reg = <0x800000 0x37c0000>;
-			};
-
-			partition@3fc0000 {
-				bootph-all;
-				label = "ospi.phypattern";
-				reg = <0x3fc0000 0x40000>;
-			};
-		};
-	};
-
-	ospi0_nand: nand@0 {
-		compatible = "spi-nand";
-		reg = <0x0>;
-		spi-tx-bus-width = <8>;
-		spi-rx-bus-width = <8>;
-		spi-max-frequency = <25000000>;
-		cdns,tshsl-ns = <60>;
-		cdns,tsd2d-ns = <60>;
-		cdns,tchsh-ns = <60>;
-		cdns,tslch-ns = <60>;
-		cdns,read-delay = <2>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-		bootph-all;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "ospi_nand.tiboot3";
-				reg = <0x0 0x80000>;
-			};
-
-			partition@80000 {
-				label = "ospi_nand.tispl";
-				reg = <0x80000 0x200000>;
-			};
-
-			partition@280000 {
-				label = "ospi_nand.u-boot";
-				reg = <0x280000 0x400000>;
-			};
-
-			partition@680000 {
-				label = "ospi_nand.env";
-				reg = <0x680000 0x40000>;
-			};
-
-			partition@6c0000 {
-				label = "ospi_nand.env.backup";
-				reg = <0x6c0000 0x40000>;
-			};
-
-			partition@2000000 {
-				label = "ospi_nand.rootfs";
-				reg = <0x2000000 0x5fc0000>;
-			};
-
-			partition@7fc0000 {
-				bootph-all;
-				label = "ospi_nand.phypattern";
-				reg = <0x7fc0000 0x40000>;
-			};
-		};
-	};
 };
 
 &sdhci0 {
@@ -520,43 +411,32 @@
 	bootph-all;
 };
 
-&serdes0_ln_ctrl {
-	idle-states = <J722S_SERDES0_LANE0_USB>;
-};
-
-&serdes0 {
+&cpsw3g {
 	status = "okay";
-	serdes0_usb_link: phy@0 {
-		reg = <0>;
-		cdns,num-lanes = <1>;
-		#phy-cells = <0>;
-		cdns,phy-type = <PHY_TYPE_USB3>;
-		resets = <&serdes_wiz0 1>;
-	};
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmii1_pins_default>;
 };
 
-&usbss0 {
+&cpsw3g_mdio {
 	status = "okay";
-	ti,vbus-divider;
-};
+	pinctrl-names = "default";
+	pinctrl-0 = <&mdio_pins_default>;
 
-&usb0 {
-	dr_mode = "otg";
-	usb-role-switch;
+	cpsw3g_phy0: ethernet-phy@0 {
+		reg = <0>;
+		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
+		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
+		ti,min-output-impedance;
+	};
 };
 
-&usbss1 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&main_usb1_pins_default>;
-	ti,vbus-divider;
+&cpsw_port1 {
+	phy-mode = "rgmii-rxid";
+	phy-handle = <&cpsw3g_phy0>;
 };
 
-&usb1 {
-	dr_mode = "host";
-	maximum-speed = "super-speed";
-	phys = <&serdes0_usb_link>;
-	phy-names = "cdns3,usb3-phy";
+&cpsw_port2 {
+	status = "disabled";
 };
 
 &mailbox0_cluster0 {
@@ -639,3 +519,43 @@
 	memory-region = <&c7x_1_dma_memory_region>,
 			<&c7x_1_memory_region>;
 };
+
+&serdes0_ln_ctrl {
+	idle-states = <J722S_SERDES0_LANE0_USB>;
+};
+
+&serdes0 {
+	status = "okay";
+	serdes0_usb_link: phy@0 {
+		reg = <0>;
+		cdns,num-lanes = <1>;
+		#phy-cells = <0>;
+		cdns,phy-type = <PHY_TYPE_USB3>;
+		resets = <&serdes_wiz0 1>;
+	};
+};
+
+&usbss0 {
+	status = "okay";
+	ti,vbus-divider;
+};
+
+&usb0 {
+	dr_mode = "host";
+	usb-role-switch;
+};
+
+&usbss1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&main_usb1_pins_default>;
+	ti,vbus-divider;
+};
+
+&usb1 {
+	dr_mode = "host";
+	maximum-speed = "super-speed";
+	phys = <&serdes0_usb_link>;
+	phy-names = "cdns3,usb3-phy";
+};
+
diff --git a/board/ti/j722s/Kconfig b/board/ti/j722s/Kconfig
index 68c214e473b..37f9c092caa 100644
--- a/board/ti/j722s/Kconfig
+++ b/board/ti/j722s/Kconfig
@@ -6,13 +6,36 @@
 if TARGET_J722S_R5_EVM || TARGET_J722S_A53_EVM
 
 config SYS_BOARD
-       default "j722s"
+    default "j722s"
 
 config SYS_VENDOR
-       default "ti"
+    default "ti"
 
 config SYS_CONFIG_NAME
-       default "j722s_evm"
+    default "j722s_evm"
+
+config BOOT_MMC_DEV_0
+    def_bool y
+
+config RECOVERY_KEY
+    bool "Config recovery key enable/disable"
+    default y
+    help
+      This config recovery key enable/disable.
+
+config RECOVERY_KEY_GPIO
+    int "Config recovery key gpio pin value"
+    depends on RECOVERY_KEY
+    default 3
+    help
+      This config recovery key gpio pin value.
+
+config RECOVERY_KEY_DELAY
+    int "Config recovery key press delay time, defaule 5 second"
+    depends on RECOVERY_KEY
+    default 2
+    help
+      This config recovery key press delay time, default 5 second.
 
 source "board/ti/common/Kconfig"
 
@@ -21,6 +44,6 @@ endif
 if TARGET_J722S_R5_EVM
 
 config SPL_LDSCRIPT
-	default "arch/arm/mach-omap2/u-boot-spl.lds"
+    default "arch/arm/mach-omap2/u-boot-spl.lds"
 
 endif
diff --git a/board/ti/j722s/evm.c b/board/ti/j722s/evm.c
index bda761f6757..47722710212 100644
--- a/board/ti/j722s/evm.c
+++ b/board/ti/j722s/evm.c
@@ -15,8 +15,9 @@
 #include <env.h>
 #include <fdt_support.h>
 #include <spl.h>
-#include "../common/fdt_ops.h"
+#include <linux/delay.h>
 
+#include "../common/fdt_ops.h"
 #include "../common/k3-ddr-init.h"
 
 ofnode cadence_qspi_get_subnode(struct udevice *dev)
@@ -30,45 +31,9 @@ ofnode cadence_qspi_get_subnode(struct udevice *dev)
 	return dev_read_first_subnode(dev);
 }
 
-/* Enables the spi-nand dts node, if onboard mux is set to spinand */
-static void __maybe_unused detect_enable_spinand(void *blob)
-{
-	if (IS_ENABLED(CONFIG_DM_GPIO) && IS_ENABLED(CONFIG_OF_LIBFDT)) {
-		struct gpio_desc desc = {0};
-		char *ospi_mux_sel_gpio = "gpio@23_1";
-		int nand_offset, nor_offset;
-
-		if (dm_gpio_lookup_name(ospi_mux_sel_gpio, &desc))
-			return;
-
-		if (dm_gpio_request(&desc, ospi_mux_sel_gpio))
-			return;
-
-		if (dm_gpio_set_dir_flags(&desc, GPIOD_IS_IN))
-			return;
-
-		nand_offset = fdt_node_offset_by_compatible(blob, -1, "spi-nand");
-		if (nand_offset < 0)
-			return;
-
-		nor_offset = fdt_node_offset_by_compatible(blob,
-							   fdt_parent_offset(blob, nand_offset),
-							   "jedec,spi-nor");
-
-		if (dm_gpio_get_value(&desc)) {
-			fdt_status_okay(blob, nand_offset);
-			fdt_del_node(blob, nor_offset);
-		} else {
-			fdt_del_node(blob, nand_offset);
-		}
-	}
-}
-
 #if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
 int ft_board_setup(void *blob, struct bd_info *bd)
 {
-	detect_enable_spinand(blob);
-
 	return 0;
 }
 #endif
@@ -101,8 +66,6 @@ void spl_perform_fixups(struct spl_image_info *spl_image)
 	} else {
 		fixup_memory_node(spl_image);
 	}
-
-	detect_enable_spinand(spl_image->fdt_addr);
 }
 #endif
 
@@ -110,6 +73,7 @@ void spl_perform_fixups(struct spl_image_info *spl_image)
 int board_late_init(void)
 {
 	ti_set_fdt_env(NULL, NULL);
+
 	return 0;
 }
 #endif
diff --git a/common/autoboot.c b/common/autoboot.c
index 5d331991c19..5251d628488 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -25,6 +25,7 @@
 #include <bootcount.h>
 #include <crypt.h>
 #include <dm/ofnode.h>
+#include <asm/gpio.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -38,6 +39,290 @@ DECLARE_GLOBAL_DATA_PTR;
 
 /* Stored value of bootdelay, used by autoboot_command() */
 static int stored_bootdelay;
+
+
+#if defined(CONFIG_RECOVERY_KEY) && defined(CONFIG_BOARD_LATE_INIT)
+static int recovery_key_check(void)
+{
+	int val = 1; // defaultis high, press is low
+	int delay = CONFIG_RECOVERY_KEY_DELAY;
+	unsigned long ts;
+
+	if (gpio_request(CONFIG_RECOVERY_KEY_GPIO, "recoverykey")) {
+		printf("request gpio %d failed!\n", CONFIG_RECOVERY_KEY_GPIO);
+		return 0;
+	}
+
+	gpio_direction_input(CONFIG_RECOVERY_KEY_GPIO);
+	val = gpio_get_value(CONFIG_RECOVERY_KEY_GPIO);
+
+	while ((delay > 0) && (!val))
+	{
+		--delay;
+		/// delay 1000 ms
+		ts = get_timer(0);
+		do {
+			val = gpio_get_value(CONFIG_RECOVERY_KEY_GPIO);
+			udelay(10000);
+		} while (!val && get_timer(ts) < 1000);
+	}
+
+	if (!val) {
+		env_set("recovery_key", "y");
+		env_set("recovery_mode", "recovery_mode=key"); // key or file
+	}
+
+	gpio_free(CONFIG_RECOVERY_KEY_GPIO);
+	return !val;
+}
+#else
+static int recovery_key_check(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_BOOT_MMC_DEV_0) || defined(CONFIG_BOOT_MMC_DEV_1)
+static int advupdate(const char *ifname, const char *dev_part, const char *s)
+{
+	int ret = 0;
+	char buf[256] = {0};
+	bool haveconfig = true;
+	bool haveupdatebin = true;
+
+	//start usb device
+	if (!strcmp(ifname, "usb"))
+	{
+		run_command("usb start", 0);
+
+		//load config file
+		env_set_ulong("filesize", 0);
+		sprintf(buf, "fatload %s %s ${loadaddr} ${advufile};env import -t ${loadaddr} ${filesize}", ifname, dev_part);
+		run_command_list(buf, -1, 0);
+		if (env_get_ulong("filesize", 16, 0) == 0) {
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "load %s %s ${loadaddr} ${advufile};env import -t ${loadaddr} ${filesize}", ifname, dev_part);
+			run_command_list(buf, -1, 0);
+			if (env_get_ulong("filesize", 16, 0) == 0) {
+				// config file not found!
+				//printf("%s %s config file not found!\n", ifname, dev_part);
+				haveconfig = false;
+			}
+		}
+
+		// find update.bin file
+		if (!haveconfig)
+		{
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "if test -e %s %s update.bin; then setenv advupdatebin y; fi", ifname, dev_part);
+			run_command_list(buf, -1, 0);
+			if (env_get_yesno("advupdatebin") != 1)
+			{
+				// update.bin file not found!
+				//printf("%s %s update.bin file not found!\n", ifname, dev_part);
+				haveupdatebin = false;
+			}
+		}
+
+		// check recovery key press
+		if (!haveupdatebin)
+		{
+			if (env_get_yesno("recovery_key") != 1)
+			{
+				//printf("%s recovery key don't press!\n", ifname);
+				return 0;
+			}
+		}
+	}
+	else if (!strcmp(ifname, "mmc"))
+	{
+		//load config file
+		env_set_ulong("filesize",0);
+		sprintf(buf, "fatload %s %s ${loadaddr} ${advufile};env import -t ${loadaddr} ${filesize}", ifname, dev_part);
+		run_command_list(buf, -1, 0);
+		if (env_get_ulong("filesize", 16, 0) == 0) {
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "load %s %s ${loadaddr} ${advufile};env import -t ${loadaddr} ${filesize}", ifname, dev_part);
+			run_command_list(buf, -1, 0);
+			if (env_get_ulong("filesize", 16, 0) == 0) {
+				// config file not found!
+				//printf("%s %s config file not found!\n", ifname, dev_part);
+				haveconfig = false;
+			}
+		}
+
+		// find update.bin file
+		if (!haveconfig)
+		{
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "if test -e %s %s update.bin; then setenv advupdatebin y; fi", ifname, dev_part);
+			run_command_list(buf, -1, 0);
+			if (env_get_yesno("advupdatebin") != 1)
+			{
+				// update.bin file not found!
+				//printf("%s %s update.bin file not found!\n", ifname, dev_part);
+				haveupdatebin = false;
+			}
+		}
+
+		// check recovery key press
+		if (!haveupdatebin)
+		{
+			if (env_get_yesno("recovery_key") != 1)
+			{
+				//printf("%s recovery key don't press!\n", ifname);
+				return 0;
+			}
+		}
+	}
+	else if (!strcmp(ifname, "nand"))
+	{
+		memset(buf, 0, sizeof(buf));
+		sprintf(buf, "ubi part NAND.recovery && ubifsmount ubi0;ubifsload ${loadaddr} ${advufile};env import -t ${loadaddr} ${filesize}");
+		run_command_list(buf, -1, 0);
+		run_command_list("ubifsumount", -1, 0);
+		if (env_get_ulong("filesize", 16, 0) == 0) {
+			// config file not found!
+			//printf("nand config file not found!!\n");
+			haveconfig = false;
+		}
+
+		// find update.bin file
+		if (!haveconfig)
+		{
+			memset(buf, 0, sizeof(buf));
+			sprintf(buf, "ubi part NAND.recovery && ubifsmount ubi0;ubifsload ${loadaddr} update.bin 0x10;env import -t ${loadaddr} 0x10");
+			run_command_list(buf, -1, 0);
+			run_command_list("ubifsumount", -1, 0);
+			if (env_get_ulong("filesize", 16, 0) == 0)
+			{
+				// update.bin file not found!
+				//printf("nand update bin file not found!!\n");
+				return 0;
+			}
+			else
+			{
+				run_command("setenv advupdatebin y", 0);
+			}
+		}
+	}
+
+	if (haveconfig)
+		printf("Config file found!\n");
+	else if (env_get_yesno("advupdatebin") == 1)
+		printf("update.bin file found!\n");
+	else if (env_get_yesno("recovery_key") == 1)
+		printf("recovery key pressed!\n");
+	else
+	{
+		printf("Normal boot mode!\n");
+		return 0;
+	}
+
+	if ((env_get_ulong("filesize",16,0) > 0) || (env_get_yesno("advupdatebin") == 1) || (env_get_yesno("recovery_key") == 1))
+	{
+		// ramdisk boot
+		if ((env_get_yesno("advimage") == 1) || (env_get_yesno("advrootfs") == 1) || (env_get_yesno("advrecover") == 1) || (env_get_yesno("advupdatebin") == 1) || (env_get_yesno("recovery_key") == 1))
+		{
+			ret = 2;
+			printf("\n================Enter Recovery Mode!================\n\n");
+			if (!strcmp(ifname, "mmc"))
+			{
+#if defined(CONFIG_BOOT_MMC_DEV_0)
+				if (env_get_yesno("advupdatebin") == 1)
+				{
+					run_command("setenv mmcdev 0", 0);
+					run_command("setenv mmcpart 3", 0);
+				}
+				else
+				{
+					if (!strcmp(dev_part, "1:1")) // SD
+					{
+						run_command("setenv mmcdev 1", 0);
+						run_command("setenv mmcpart 1", 0);
+					}
+					else if (!strcmp(dev_part, "0:3")) // emmc
+					{
+						run_command("setenv mmcdev 0", 0);
+						run_command("setenv mmcpart 3", 0);
+					}
+				}
+#elif defined(CONFIG_BOOT_MMC_DEV_1)
+				if (env_get_yesno("advupdatebin") == 1)
+				{
+					run_command("setenv mmcdev 1", 0);
+					run_command("setenv mmcpart 3", 0);
+				}
+				else
+				{
+					if (!strcmp(dev_part, "0:1"))
+					{
+						run_command("setenv mmcdev 0", 0);
+						run_command("setenv mmcpart 1", 0);
+					}
+					else if (!strcmp(dev_part, "1:3"))
+					{
+						run_command("setenv mmcdev 1", 0);
+						run_command("setenv mmcpart 3", 0);
+					}
+				}
+#else // default is CONFIG_BOOT_MMC_DEV_0
+				if (env_get_yesno("advupdatebin") == 1)
+				{
+					run_command("setenv mmcdev 0", 0);
+					run_command("setenv mmcpart 3", 0);
+				}
+				else
+				{
+					if (!strcmp(dev_part, "1:1"))
+					{
+						run_command("setenv mmcdev 1", 0);
+						run_command("setenv mmcpart 1", 0);
+					}
+					else if (!strcmp(dev_part, "0:3"))
+					{
+						run_command("setenv mmcdev 0", 0);
+						run_command("setenv mmcpart 3", 0);
+					}
+				}
+#endif
+				run_command("mmc dev ${mmcdev}", 0);
+
+				s = env_get("advrfs");
+				run_command_list(s, -1, 0);
+			}
+			else if (!strcmp(ifname, "usb"))
+			{
+				s = env_get("advusbrfs");
+				run_command_list(s, -1, 0);
+			}
+			else if (!strcmp(ifname, "nand"))
+			{
+				if (env_get_yesno("advupdatebin") == 1)
+				{
+					s = env_get("nandrd_boot_oldimage");
+					run_command_list(s, -1, 0);
+				}
+				else
+				{
+					s = env_get("nandrd_boot");
+					run_command_list(s, -1, 0);
+				}
+			}
+		}
+		else
+		{
+			printf("System boot mode!\n");
+			s = env_get("bootcmd");
+		}
+	}
+	else
+		printf("Normal boot mode!!\n");
+
+	return ret;
+}
+#endif
+
 static int menukey;
 
 #if defined(CONFIG_AUTOBOOT_STOP_STR_CRYPT)
@@ -498,6 +783,51 @@ void autoboot_command(const char *s)
 		if (lock)
 			prev = disable_ctrlc(1); /* disable Ctrl-C checking */
 
+#if defined(CONFIG_BOOT_MMC_DEV_0)
+		{
+		int ret = 0;
+
+		ret = advupdate("usb", "0:1", s);
+		if (!ret)
+		{
+			ret = advupdate("mmc", "1:1", s); // SD boot
+			if (!ret)
+			{
+				ret = advupdate("mmc", "0:3", s); // emmc recovery
+				if (!ret)
+				{
+					ret = recovery_key_check();
+					if (ret)
+					{
+						ret = advupdate("mmc", "0:3", s); // emmc recovery
+					}
+				}
+			}
+		}
+		}
+#elif defined(CONFIG_BOOT_MMC_DEV_1)
+		{
+		int ret = 0;
+
+		ret = advupdate("usb", "0:1", s);
+		if (!ret)
+		{
+			ret = advupdate("mmc", "0:1", s); // SD boot
+			if (!ret)
+			{
+				ret = advupdate("mmc", "1:3", s);
+				if (!ret)
+				{
+					ret = recovery_key_check();
+					if (ret)
+					{
+						ret = advupdate("mmc", "1:3", s); // emmc recovery
+					}
+				}
+			}
+		}
+		}
+#endif
 		run_command_list(s, -1, 0);
 
 		if (lock)
diff --git a/configs/j722s_evm_a53_defconfig b/configs/j722s_evm_a53_defconfig
index ea4bb06ff5e..ac9c9517c6d 100644
--- a/configs/j722s_evm_a53_defconfig
+++ b/configs/j722s_evm_a53_defconfig
@@ -7,11 +7,17 @@ CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
 CONFIG_NR_DRAM_BANKS=2
 CONFIG_SOC_K3_J722S=y
+#CONFIG_TARGET_J722S_A53_ECU1270=y
 CONFIG_TARGET_J722S_A53_EVM=y
 CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x80480000
 CONFIG_SF_DEFAULT_SPEED=25000000
 CONFIG_ENV_SIZE=0x40000
+CONFIG_BOOTDELAY=1
+CONFIG_AUTOBOOT_KEYED=y
+CONFIG_AUTOBOOT_PROMPT="Press ENTER to stop autoboot in %d seconds\n"
+CONFIG_AUTOBOOT_STOP_STR="\x0d"
+CONFIG_BOOT_MMC_DEV_0=y
 CONFIG_DM_GPIO=y
 CONFIG_SPL_DM_SPI=y
 CONFIG_DEFAULT_DEVICE_TREE="k3-j722s-evm"
@@ -31,6 +37,7 @@ CONFIG_SPL_LOAD_FIT_ADDRESS=0x81000000
 CONFIG_BOOTSTD_FULL=y
 CONFIG_BOOTSTD_DEFAULTS=y
 CONFIG_BOARD_LATE_INIT=y
+CONFIG_BOOTCOMMAND="run envboot; run bsp_bootcmd;"
 CONFIG_SPL_MAX_SIZE=0x58000
 CONFIG_SPL_PAD_TO=0x0
 CONFIG_SPL_HAS_BSS_LINKER_SECTION=y
@@ -64,6 +71,7 @@ CONFIG_CMD_CLK=y
 CONFIG_CMD_DFU=y
 CONFIG_CMD_DM=y
 CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPIO_READ=y
 CONFIG_CMD_GPT=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
@@ -163,10 +171,14 @@ CONFIG_SPL_SYSRESET=y
 CONFIG_SYSRESET_TI_SCI=y
 CONFIG_DM_THERMAL=y
 CONFIG_USB=y
+CONFIG_USB_HOST=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_SPL_DM_USB_GADGET=y
 CONFIG_SPL_USB_HOST=y
 CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_CDNS3=y
+CONFIG_SPL_USB_CDNS3_HOST=y
+CONFIG_USB_CDNS3_HOST=y
 CONFIG_USB_DWC3=y
 CONFIG_USB_DWC3_GENERIC=y
 CONFIG_SPL_USB_DWC3_GENERIC=y
diff --git a/include/configs/j722s_evm.h b/include/configs/j722s_evm.h
index 10f2e2d3edc..bf509d30052 100644
--- a/include/configs/j722s_evm.h
+++ b/include/configs/j722s_evm.h
@@ -11,4 +11,103 @@
 /* Now for the remaining common defines */
 #include <configs/ti_armv7_common.h>
 
+#define FDTFILE_DEFAULT		"k3-j722s-ecu1270.dtb"
+
+/* Initial environment variables */
+#define CFG_EXTRA_ENV_SETTINGS          \
+	"boot=mmc\0" 						\
+	"mmcdev=0\0"						\
+	"bootpart=0:1\0"					\
+	"bootdir=\0"						\
+	"fdt_file="FDTFILE_DEFAULT"\0" 		\
+	"get_overlay_adv=fdt address ${fdt_addr_r}; fdt resize 0x100000; for overlay in $name_overlays; do; load mmc ${bootpart} ${dtboaddr} ${bootdir}/${overlay} && fdt apply ${dtboaddr}; done;\0" \
+	"get_fdt_adv=load mmc ${bootpart} ${fdt_addr_r} ${fdt_file}\0" \
+	"get_kern_adv=load mmc ${bootpart} ${loadaddr} ${name_kern}\0" \
+	"get_fit_adv=load mmc ${bootpart} ${addr_fit} ${name_fit}\0" \
+	"mmc_args=setenv bootargs console=${console} ${optargs} root=${mmcroot} rw rootfstype=${mmcrootfstype};\0" \
+	"mmc_loados=" \
+		"if test ${boot_fit} -eq 1; then " \
+			"run get_fit_adv; run get_fit_overlaystring; run run_fit; " \
+		"else " \
+			"run get_kern_adv; run get_fdt_adv; run get_overlay_adv; run run_kern; " \
+		"fi\0" \
+	"mmc_boot=echo Booting from mmc ...; setenv mmcdev 1; setenv bootpart 1:1; setenv mmcroot /dev/mmcblk1p2; " \
+		"setenv fdtfile ${fdt_file}; " \
+		"run mmc_args; " \
+		"mmc dev ${mmcdev}; " \
+		"setenv devnum ${mmcdev}; " \
+		"setenv devtype mmc; " \
+		"run mmc_loados\0" \
+    "emmc_boot=echo Booting from emmc ...; setenv mmcdev 0; setenv bootpart 0:1; setenv mmcroot /dev/mmcblk0p2; " \
+		"setenv fdtfile ${fdt_file}; " \
+		"run mmc_args; " \
+		"mmc dev ${mmcdev}; " \
+		"setenv devnum ${mmcdev}; " \
+		"setenv devtype mmc; " \
+		"run mmc_loados;\0" \
+	"advufile=advupdate.txt\0" \
+	"ramrootfstype=ext2 rootwait\0" \
+	"loadramdisk=load mmc ${mmcdev} ${ramdisk_addr_r} ramdisk.gz\0" \
+	"loadusbimage=load usb ${usbdev}:${usbpart} ${loadaddr} ${name_kern}\0" \
+	"loadusbfdt=load usb ${usbdev}:${usbpart} ${fdt_addr_r} ${fdt_file}\0" \
+	"loadusbramdisk=load usb ${usbdev}:${usbpart} ${ramdisk_addr_r} ramdisk.gz\0" \
+	"advrargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=/dev/ram0 rw ramdisk_size=65536 "\
+		"initrd=${ramdisk_addr_r},64M " \
+		"rootfstype=${ramrootfstype}\0" \
+	"advrfs=echo Advantech recovery file system ramdisk ...; " \
+		"setenv devnum ${mmcdev}; " \
+		"setenv devtype mmc; " \
+		"setenv bootpart ${mmcdev}:${mmcpart}; " \
+		"setenv fdtfile ${fdt_file}; " \
+		"run get_kern_adv; " \
+		"run loadramdisk; " \
+		"run advrargs; " \
+		"if run get_fdt_adv; then " \
+			"booti ${loadaddr} - ${fdt_addr_r}; " \
+		"else " \
+			"booti ${loadaddr};" \
+		"fi;\0" \
+	"advusbrfs=echo Advantech Recovery System ...; " \
+		"usb start; " \
+		"setenv usbdev 0; " \
+		"setenv usbpart 1; " \
+		"setenv devtype usb; " \
+		"run advrargs; " \
+		"run loadusbimage; " \
+		"run loadusbramdisk; " \
+		"if run loadusbfdt; then " \
+			"booti ${kernel_addr_r} - ${fdt_addr_r}; " \
+		"else " \
+			"echo advusbrfs load image/fdt file failed!; " \
+		"fi\0" \
+	"get_fdt_file=" \
+	    "if gpio input gpio@600000_51; then " \
+	        "if gpio input gpio@600000_50; then " \
+                "setenv board_id_3_2 00; " \
+            "else " \
+                "setenv board_id_3_2 01; " \
+            "fi; " \
+        "else " \
+            "if gpio input gpio@600000_50; then " \
+                "setenv board_id_3_2 10; " \
+                "setenv fdt_file k3-j722s-ecu1270-dio.dtb; " \
+            "else " \
+                "setenv board_id_3_2 11; " \
+            "fi; " \
+		"fi;\0" \
+	"bsp_bootcmd=echo Running BSP bootcmd ...; " \
+		"mmc dev ${mmcdev}; " \
+		"if mmc rescan; then " \
+			"run get_fdt_file; " \
+			"if run get_kern_adv; then " \
+				"run emmc_boot; " \
+			"else " \
+				"run mmc_boot; " \
+			"fi; " \
+		"fi;\0"
+
+#define CONFIG_SYS_USB_FAT_BOOT_PARTITION 1
+
 #endif /* __CONFIG_J722S_EVM_H */
