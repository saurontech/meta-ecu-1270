From 191583a4da93203b3d19f70c5d7ccab8bc426a4e Mon Sep 17 00:00:00 2001
From: "suricata.lu" <suricata.lu@gmail.com>
Date: Thu, 18 Dec 2025 00:59:25 +0800
Subject: [PATCH] add-hdmi-support

---
 arch/arm64/boot/dts/ti/k3-j722s-ecu1270.dts |  304 ++--
 arch/arm64/configs/defconfig                |    1 +
 drivers/gpu/drm/bridge/Kconfig              |   11 +
 drivers/gpu/drm/bridge/Makefile             |    1 +
 drivers/gpu/drm/bridge/lontium-lt9611uxd.c  | 1387 +++++++++++++++++++
 5 files changed, 1601 insertions(+), 103 deletions(-)
 create mode 100644 drivers/gpu/drm/bridge/lontium-lt9611uxd.c

diff --git a/arch/arm64/boot/dts/ti/k3-j722s-ecu1270.dts b/arch/arm64/boot/dts/ti/k3-j722s-ecu1270.dts
index 95adcbc52352..3a535464763d 100644
--- a/arch/arm64/boot/dts/ti/k3-j722s-ecu1270.dts
+++ b/arch/arm64/boot/dts/ti/k3-j722s-ecu1270.dts
@@ -11,11 +11,12 @@
 #include <dt-bindings/net/ti-dp83867.h>
 #include <dt-bindings/leds/common.h>
 #include <dt-bindings/phy/phy.h>
+#include <dt-bindings/gpio/gpio.h>
 #include "k3-j722s.dtsi"
 #include "k3-serdes.h"
 
 / {
-	compatible = "ti,j722s-evm", "ti,j722s";
+	compatible = "ti,j722s-ecu1270", "ti,j722s";
 	model = "Texas Instruments J722S ECU1270";
 
 	aliases {
@@ -134,8 +135,7 @@ c7x_1_memory_region: c7x-memory@a4100000 {
 		};
 
 		rtos_ipc_memory_region: ipc-memories@a5000000 {
-			reg = <0x00 0xa5000000 0x00 0x00800000>; // 2G
-			//reg = <0x00 0xa5000000 0x00 0x1c00000>; // 4G
+			reg = <0x00 0xa5000000 0x00 0x1c00000>; // 4G
 			alignment = <0x1000>;
 			no-map;
 		};
@@ -187,16 +187,6 @@ vdd_sd_dv: regulator-TLV71033 {
 			 <3300000 0x1>;
 	};
 
-	vcc_3v3_aud: regulator-vcc3v3 {
-		/* Output of LM5140 */
-		compatible = "regulator-fixed";
-		regulator-name = "vcc_3v3";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-always-on;
-		regulator-boot-on;
-	};
-
 	vsys_io_1v8: regulator-vsys-io-1v8 {
 		compatible = "regulator-fixed";
 		regulator-name = "vsys_io_1v8";
@@ -215,6 +205,33 @@ vsys_io_1v2: regulator-vsys-io-1v2 {
 		regulator-boot-on;
 	};
 
+	 /* [HDMI] LT9611 晶片的核心電源 (1.2V) */
+    lt9611_1v2: lt9611-vdd12-regulator {
+        compatible = "regulator-fixed";
+        regulator-name = "LT9611_1V2";
+        regulator-min-microvolt = <1200000>;
+        regulator-max-microvolt = <1200000>;
+		regulator-always-on;
+		regulator-boot-on;
+    };
+
+	/* [HDMI] LT9611 晶片的 I/O 電源 (3.3V) */
+    lt9611_3v3: lt9611-3v3-regulator {
+        compatible = "regulator-fixed";
+        regulator-name = "LT9611_3V3";
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+    };
+
+	adv_board {
+        compatible = "custom,adv-board";
+        board_name = "ECU1270";
+
+		reset-gpios = <&main_gpio0 10 GPIO_ACTIVE_LOW>;	// minipcie reset
+    };
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
@@ -225,6 +242,42 @@ PL-1 {
 			gpios = <&main_gpio1 13 GPIO_ACTIVE_HIGH>;
 			default-state = "off";
 		};
+
+		COM-MODE-SEL-0 {
+			label = "com_mode_sel_0";
+			gpios = <&main_gpio1 30 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		COM-MODE-SEL-1 {
+			label = "com_mode_sel_1";
+			gpios = <&main_gpio1 14 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+        M2_SLOG_RESET {
+			label = "SLOT_RESET_1_1_2_USB";
+			gpios = <&main_gpio0 11 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+
+        PCIE_SLOG_RESET {
+			label = "SLOT_RESET_1_1_1_USB";
+			gpios = <&main_gpio0 10 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+
+        M2_SLOG_POWER {
+			label = "SLOT_POWER_1_1_2_USB";
+			gpios = <&main_gpio1 7 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+
+        PCIE_SLOG_POWER {
+			label = "SLOT_POWER_1_1_1_USB";
+			gpios = <&main_gpio1 12 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
 	};
 
 	transceiver0: can-phy0 {
@@ -274,22 +327,34 @@ clk_ext_cec: clk-ext-cec {
 		};
 	};
 
+	/* [HDMI] 定義實體的 HDMI 插座 */
 	hdmi-out {
 		compatible = "hdmi-connector";
 		label = "hdmi";
-		type = "a";
+		type = "a";  /* Type A 就是標準大小的 HDMI 接頭 */
 
 		port {
 			hdmi_connector_in: endpoint {
-				remote-endpoint = <&adv7535_out>;
+				/* 接到 LT9611 晶片的輸出端 (lt9611_out) */
+				remote-endpoint = <&lt9611_out>;
 			};
 		};
 	};
+
+    watchdog-gpio {
+        compatible = "linux,wdt-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&watchdog_gpio_pins_default>;
+        always-running;
+        gpios = <&main_gpio0 6 GPIO_ACTIVE_LOW>;
+        wdt_en-gpios = <&main_gpio0 8 GPIO_ACTIVE_HIGH>;
+        hw_algo = "toggle";
+        hw_margin_ms = <1500>;
+        status = "okay";
+	};
 };
 
 &main_pmx0 {
-
-	/delete-property/ interrupts;
 	main_i2c0_pins_default: main-i2c0-default-pins {
 		pinctrl-single,pins = <
 			J722S_IOPAD(0x01e0, PIN_INPUT_PULLUP, 0) /* (D23) I2C0_SCL */
@@ -411,11 +476,12 @@ J722S_IOPAD(0x00b0, PIN_OUTPUT, 5) /* (P22) MCAN1_TX */
 		>;
 	};
 
-	mdio_pins_default: mdio-default-pins {
+	mdio_pins_default: mdio-default-pins {  // Management Data Input/Output => Ethernet PHY 控制介面
 		pinctrl-single,pins = <
 			J722S_IOPAD(0x0160, PIN_OUTPUT, 0) /* (AC24) MDIO0_MDC */
 			J722S_IOPAD(0x015c, PIN_INPUT, 0) /* (AD25) MDIO0_MDIO */
 		>;
+		bootph-all;
 	};
 
 	rgmii1_pins_default: rgmii1-default-pins {
@@ -433,6 +499,7 @@ J722S_IOPAD(0x0140, PIN_OUTPUT, 0) /* (AF24) RGMII1_TD3 */
 			J722S_IOPAD(0x0130, PIN_OUTPUT, 0) /* (AG26) RGMII1_TXC */
 			J722S_IOPAD(0x012c, PIN_OUTPUT, 0) /* (AF25) RGMII1_TX_CTL */
 		>;
+		bootph-all;
 	};
 
 	rgmii2_pins_default: rgmii2-default-pins {
@@ -454,15 +521,27 @@ J722S_IOPAD(0x00d8, PIN_INPUT, 2) /* (AA24) VOUT0_DATA8.RGMII2_TX_CTL */
 
 	led_pins_default: led-default-pins {
 		pinctrl-single,pins = <
-			J722S_IOPAD(0x01ac, PIN_OUTPUT_PULLUP, 7) // (C27) MCASP0_AFSR.GPIO1_13 LED1
+			J722S_IOPAD(0x01ac, PIN_INPUT, 7) // (C27) MCASP0_AFSR.GPIO1_13 LED1
+
+            // Reset_M.2
+			J722S_IOPAD(0x002c, PIN_OUTPUT, 7) /* (K26) OSPI0_CSn0.GPIO0_11 */
+
+			// PCIE_RSTN1
+			J722S_IOPAD(0x0028, PIN_OUTPUT, 7) /* (M27) OSPI0_D7.GPIO0_10 */
+
+            // PWREN_M2
+			J722S_IOPAD(0x0194, PIN_OUTPUT, 7) /* (A25) MCASP0_AXR3.GPIO1_7 */
+
+			// MPCIE3V3_EN
+			J722S_IOPAD(0x01a8, PIN_OUTPUT, 7) /* (C26) MCASP0_AFSX.GPIO1_12 */
 		>;
 	};
 
 	power_en_pins_default: power-en-default-pins {
 		pinctrl-single,pins = <
 			J722S_IOPAD(0x0010, PIN_OUTPUT_PULLUP, 7) /* (L27) OSPI0_D1.GPIO0_4 COM_PWR_EN */
-			J722S_IOPAD(0x00d4, PIN_OUTPUT_PULLUP, 7) /* (Y27) VOUT0_DATA7.GPIO0_52 */
-			J722S_IOPAD(0x00c4, PIN_OUTPUT_PULLUP, 7) /* (W23) VOUT0_DATA3.GPIO0_48 */
+			J722S_IOPAD(0x00d4, PIN_OUTPUT_PULLUP, 7) /* (Y27) VOUT0_DATA7.GPIO0_52 PWR_EN1 */
+			J722S_IOPAD(0x00c4, PIN_OUTPUT_PULLUP, 7) /* (W23) VOUT0_DATA3.GPIO0_48 PWR_EN2 */
 		>;
 	};
 
@@ -474,14 +553,14 @@ J722S_IOPAD(0x0258, PIN_INPUT, 0) /* (B27) USB1_DRVVBUS */
 	
 	main_dsi_int_pins_default: main-dsi-int-default-pins {
 		pinctrl-single,pins = <
-			J722S_IOPAD(0x0008, PIN_INPUT, 7) /* (L22) OSPI0_DQS.GPIO0_2 */
+			J722S_IOPAD(0x0008, PIN_INPUT, 7) // (L22) OSPI0_DQS.GPIO0_2
 		>;
 	};
 
 	main_gpio0_pins_default: main-gpio0-default-pins {
 		pinctrl-single,pins = <
-			J722S_IOPAD(0x007c, PIN_OUTPUT_PULLUP, 7) /* (T23) GPMC0_CLK.GPIO0_31 GPIO6 DO2 */
-			J722S_IOPAD(0x0094, PIN_OUTPUT_PULLUP, 7) /* (P26) GPMC0_BE1n.GPIO0_36 GPIO7 DO3 */
+			J722S_IOPAD(0x007c, PIN_INPUT, 7) /* (T23) GPMC0_CLK.GPIO0_31 GPIO6 DO2 */
+			J722S_IOPAD(0x0094, PIN_INPUT, 7) /* (P26) GPMC0_BE1n.GPIO0_36 GPIO7 DO3 */
 
 			// BOARD ID
 			J722S_IOPAD(0x00b8, PIN_INPUT, 7) /* (W27) VOUT0_DATA0.GPIO0_45 BID0 */
@@ -496,10 +575,10 @@ J722S_IOPAD(0x00d4, PIN_OUTPUT_PULLUP, 7) /* (Y27) VOUT0_DATA7.GPIO0_52 PWR_EN1
 			J722S_IOPAD(0x00c4, PIN_OUTPUT_PULLUP, 7) /* (W23) VOUT0_DATA3.GPIO0_48 PWR_EN2 */			
 
 			// Reset_M.2
-			J722S_IOPAD(0x002c, PIN_OUTPUT, 7) /* (K26) OSPI0_CSn0.GPIO0_11 */
+			//J722S_IOPAD(0x002c, PIN_OUTPUT, 7) /* (K26) OSPI0_CSn0.GPIO0_11 */
 
 			// PCIE_RSTN1
-			J722S_IOPAD(0x0028, PIN_OUTPUT, 7) /* (M27) OSPI0_D7.GPIO0_10 */
+			//J722S_IOPAD(0x0028, PIN_OUTPUT, 7) /* (M27) OSPI0_D7.GPIO0_10 */
 		>;
 	};
 
@@ -514,18 +593,19 @@ J722S_IOPAD(0x01a0, PIN_INPUT, 7) /* (F23) MCASP0_AXR0.GPIO1_10 */
 			J722S_IOPAD(0x019c, PIN_INPUT, 7) /* (B25) MCASP0_AXR1.GPIO1_9 */
 
 			// PWREN_M2
-			J722S_IOPAD(0x0194, PIN_OUTPUT, 7) /* (A25) MCASP0_AXR3.GPIO1_7 */
+			//J722S_IOPAD(0x0194, PIN_OUTPUT, 7) /* (A25) MCASP0_AXR3.GPIO1_7 */
 
 			// MPCIE3V3_EN
-			J722S_IOPAD(0x01a8, PIN_OUTPUT, 7) /* (C26) MCASP0_AFSX.GPIO1_12 */
+			//J722S_IOPAD(0x01a8, PIN_OUTPUT, 7) /* (C26) MCASP0_AFSX.GPIO1_12 */
 		>;
 	};
-};
 
-&ospi0 {
-	status = "okay";
-	pinctrl-names = "default"; 
-	pinctrl-0 = <&main_dsi_int_pins_default>;
+	watchdog_gpio_pins_default: watchdog-gpio-default-pins {
+		pinctrl-single,pins = <
+			J722S_IOPAD(0x0018, PIN_OUTPUT, 7) /* (L25) OSPI0_D3.GPIO0_6 WDI# */
+			J722S_IOPAD(0x0020, PIN_OUTPUT, 7) /* (M26) OSPI0_D5.GPIO0_8 WDI_EN */
+		>;
+	};
 };
 
 &main_gpio0 {
@@ -666,6 +746,51 @@ &wkup_i2c0 {
 	bootph-all;
 };
 
+&main_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&main_i2c0_pins_default>;
+	clock-frequency = <400000>;
+	status = "okay";
+	bootph-all;
+
+    lt9611_codec: hdmi-bridge@41 {
+        compatible = "lontium,lt9611uxd";
+        reg = <0x41>;
+		#sound-dai-cells = <0>;
+
+        pinctrl-names = "default";
+        pinctrl-0 = <&main_dsi_int_pins_default>;
+		interrupt-parent = <&main_gpio0>;
+		interrupts = <2 IRQ_TYPE_EDGE_FALLING>;
+
+        vdd-supply = <&lt9611_1v2>;
+        vcc-supply = <&lt9611_3v3>;
+        dsi-lanes = <4>;
+        status = "okay";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                reg = <0>;
+
+                lt9611_a: endpoint {
+                    remote-endpoint = <&dsi0_out>;
+                };
+            };
+
+            port@2 {
+                reg = <2>;
+
+                lt9611_out: endpoint {
+                    remote-endpoint = <&hdmi_connector_in>;
+                };
+            };
+        };
+    };
+};
+
 &main_i2c3 {
 	status = "okay";
 	pinctrl-names = "default";
@@ -683,6 +808,11 @@ s35390a: s35390a@30 {
 		reg = <0x30>;
 		status = "okay";
 	};
+
+    eeprom@50 {
+		compatible = "atmel,24c02";
+        reg = <0x50>;
+	};
 };
 
 &sdhci0 {
@@ -753,6 +883,7 @@ &cpsw3g_mdio {
 
 	cpsw3g_phy0: ethernet-phy@0 {
 		reg = <0>;
+		bootph-all;
 		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
 		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
 		ti,min-output-impedance;
@@ -760,6 +891,7 @@ cpsw3g_phy0: ethernet-phy@0 {
 
 	cpsw3g_phy1: ethernet-phy@9 {
 		reg = <9>;
+		bootph-all;
 		ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
 		ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
 		ti,min-output-impedance;
@@ -767,18 +899,23 @@ cpsw3g_phy1: ethernet-phy@9 {
 };
 
 &cpsw_port1 {
+	status = "okay";
+
 	phy-mode = "rgmii-rxid";
 	phy-handle = <&cpsw3g_phy0>;
 };
 
 &cpsw_port2 {
+	status = "okay";
+
 	phy-mode = "rgmii-rxid";
 	phy-handle = <&cpsw3g_phy1>;
 };
 
 &mailbox0_cluster0 {
 	status = "okay";
-	mbox_r5_0: mbox-r5-0 {
+
+	mbox_wkup_r5_0: mbox-wkup-r5-0 {
 		ti,mbox-rx = <0 0 0>;
 		ti,mbox-tx = <1 0 0>;
 	};
@@ -786,6 +923,7 @@ mbox_r5_0: mbox-r5-0 {
 
 &mailbox0_cluster1 {
 	status = "okay";
+
 	mbox_mcu_r5_0: mbox-mcu-r5-0 {
 		ti,mbox-rx = <0 0 0>;
 		ti,mbox-tx = <1 0 0>;
@@ -794,6 +932,7 @@ mbox_mcu_r5_0: mbox-mcu-r5-0 {
 
 &mailbox0_cluster2 {
 	status = "okay";
+
 	mbox_c7x_0: mbox-c7x-0 {
 		ti,mbox-rx = <0 0 0>;
 		ti,mbox-tx = <1 0 0>;
@@ -802,6 +941,7 @@ mbox_c7x_0: mbox-c7x-0 {
 
 &mailbox0_cluster3 {
 	status = "okay";
+
 	mbox_main_r5_0: mbox-main-r5-0 {
 		ti,mbox-rx = <0 0 0>;
 		ti,mbox-tx = <1 0 0>;
@@ -830,7 +970,7 @@ &wkup_r5fss0 {
 };
 
 &wkup_r5fss0_core0 {
-	mboxes = <&mailbox0_cluster0 &mbox_r5_0>;
+	mboxes = <&mailbox0_cluster0 &mbox_wkup_r5_0>;
 	memory-region = <&wkup_r5fss0_core0_dma_memory_region>,
 			<&wkup_r5fss0_core0_memory_region>;
 };
@@ -856,17 +996,17 @@ &main_r5fss0_core0 {
 };
 
 &c7x_0 {
-	status = "okay";
 	mboxes = <&mailbox0_cluster2 &mbox_c7x_0>;
 	memory-region = <&c7x_0_dma_memory_region>,
 			<&c7x_0_memory_region>;
+	status = "okay";
 };
 
 &c7x_1 {
-	status = "okay";
 	mboxes = <&mailbox0_cluster3 &mbox_c7x_1>;
 	memory-region = <&c7x_1_dma_memory_region>,
 			<&c7x_1_memory_region>;
+	status = "okay";
 };
 
 &serdes_ln_ctrl {
@@ -874,6 +1014,10 @@ &serdes_ln_ctrl {
 		      <J722S_SERDES1_LANE0_PCIE0_LANE0>;
 };
 
+&serdes_wiz0 {
+	status = "okay";
+};
+
 &serdes0 {
 	status = "okay";
 	serdes0_usb_link: phy@0 {
@@ -885,7 +1029,12 @@ serdes0_usb_link: phy@0 {
 	};
 };
 
+&serdes_wiz1 {
+	status = "okay";
+};
+
 &serdes1 {
+	status = "okay";
 	serdes1_pcie_link: phy@0 {
 		reg = <0>;
 		cdns,num-lanes = <1>;
@@ -895,6 +1044,13 @@ serdes1_pcie_link: phy@0 {
 	};
 };
 
+&pcie0_rc {
+	// reset-gpios = <&main_gpio0 11 GPIO_ACTIVE_HIGH>; // Reset_M.2 (K26) OSPI0_CSn0.GPIO0_11
+	phys = <&serdes1_pcie_link>;
+	phy-names = "pcie-phy";
+	status = "okay";
+};
+
 &usbss0 {
 	ti,vbus-divider;
 	status = "okay";
@@ -919,13 +1075,7 @@ &usb1 {
 	phy-names = "cdns3,usb3-phy";
 };
 
-&pcie0_rc {
-	status = "okay";
-	reset-gpios = <&main_gpio0 11 GPIO_ACTIVE_HIGH>; // Reset_M.2 (K26) OSPI0_CSn0.GPIO0_11
-	phys = <&serdes1_pcie_link>;
-	phy-names = "pcie-phy";
-};
-
+/*啟用 DSI 的物理層 (PHY)*/
 &dphy_tx0 {
 	status = "okay";
 };
@@ -933,7 +1083,6 @@ &dphy_tx0 {
 &dss1 {
 	status = "okay";
 
-	//+=
 	clocks = <&k3_clks 232 8>,
 		 <&k3_clks 232 0>,
 		 <&k3_clks 232 4>;
@@ -945,6 +1094,12 @@ &dss1 {
 	assigned-clock-parents = <&k3_clks 241 2>,	/* PLL 17 HDMI */
 				 <&k3_clks 240 1>,	/* PLL 18 DSI */
 				 <&k3_clks 245 2>;	/* DSS1-DPI0 */
+	
+	oldi-txes {
+        oldi@1 {
+            status = "disabled";
+        };
+    };
 };
 
 &dss1_ports {
@@ -973,7 +1128,7 @@ ports {
 		port@0 {
 			reg = <0>;
 			dsi0_out: endpoint {
-				remote-endpoint = <&adv7535_in>;
+				remote-endpoint = <&lt9611_a>;
 			};
 		};
 
@@ -986,60 +1141,3 @@ dsi0_in: endpoint {
 	};
 };
 
-&main_i2c0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&main_i2c0_pins_default>;
-	clock-frequency = <400000>;
-	status = "okay";
-	bootph-all;
-
-	adv_bridge: bridge@3d {
-		status = "okay";
-
-		compatible = "adi,adv7535";
-		//reg = <0x3d>;
-		reg-names = "main", "cec", "edid", "packet";
-		reg = <0x3d>, <0x3c>, <0x3e>, <0x3f>;
-		adi,dsi-lanes = <4>;
-
-		avdd-supply = <&reg_1p8v>;
-		a2vdd-supply = <&reg_1p8v>;
-		dvdd-supply = <&reg_1p8v>;
-		pvdd-supply = <&reg_1p8v>;
-		v1p2-supply = <&reg_1p8v>;
-		v3p3-supply = <&reg_3p3v>;
-
-		adi,disable-timing-generator;
-		pinctrl-0 = <&main_dsi_int_pins_default>;
-    	interrupt-parent = <&main_gpio0>;
-    	interrupts = <2 IRQ_TYPE_EDGE_FALLING>;
-		//interrupt-parent = <&ospi0>; /* (L22) OSPI0_DQS.GPIO0_2 */
-		//interrupts = <2 IRQ_TYPE_EDGE_FALLING>;
-
-		ports {
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			port@0 {
-				reg = <0>;
-				adv7535_in: endpoint {
-					remote-endpoint = <&dsi0_out>;
-				};
-			};
-
-			port@1 {
-				reg = <1>;
-				adv7535_out: endpoint {
-					remote-endpoint = <&hdmi_connector_in>;
-				};
-			};
-		};
-	};
-};
-
-&vpu {
-	status = "disabled";
-};
-&main_rti15 {
-	status = "disabled";
-};
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 590be2f19bf3..6457d05604bd 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -976,6 +976,7 @@ CONFIG_DRM_FSL_LDB=m
 CONFIG_DRM_LONTIUM_LT8912B=m
 CONFIG_DRM_LONTIUM_LT9611=m
 CONFIG_DRM_LONTIUM_LT9611UXC=m
+CONFIG_DRM_LONTIUM_LT9611UXD=m
 CONFIG_DRM_ITE_IT66121=m
 CONFIG_DRM_NWL_MIPI_DSI=m
 CONFIG_DRM_PARADE_PS8640=m
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 3eb955333c80..4af4b86594a0 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -161,6 +161,17 @@ config DRM_LONTIUM_LT9611UXC
 	  HDMI signals
 	  Please say Y if you have such hardware.
 
+config DRM_LONTIUM_LT9611UXD
+    tristate "Lontium LT9611UXD DSI/HDMI bridge"
+    select SND_SOC_HDMI_CODEC if SND_SOC
+    depends on OF
+    select DRM_PANEL_BRIDGE
+    select DRM_KMS_HELPER
+    select DRM_MIPI_DSI
+    select REGMAP_I2C
+    help
+      Driver for Lontium LT9611UXD DSI to HDMI bridge.
+
 config DRM_ITE_IT66121
 	tristate "ITE IT66121 HDMI bridge"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 7df87b582dca..ba2036f02dcd 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_DRM_LONTIUM_LT8912B) += lontium-lt8912b.o
 obj-$(CONFIG_DRM_LONTIUM_LT9211) += lontium-lt9211.o
 obj-$(CONFIG_DRM_LONTIUM_LT9611) += lontium-lt9611.o
 obj-$(CONFIG_DRM_LONTIUM_LT9611UXC) += lontium-lt9611uxc.o
+obj-$(CONFIG_DRM_LONTIUM_LT9611UXD) += lontium-lt9611uxd.o
 obj-$(CONFIG_DRM_LVDS_CODEC) += lvds-codec.o
 obj-$(CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW) += megachips-stdpxxxx-ge-b850v3-fw.o
 obj-$(CONFIG_DRM_MICROCHIP_LVDS_SERIALIZER) += microchip-lvds.o
diff --git a/drivers/gpu/drm/bridge/lontium-lt9611uxd.c b/drivers/gpu/drm/bridge/lontium-lt9611uxd.c
new file mode 100644
index 000000000000..c58c15b83a64
--- /dev/null
+++ b/drivers/gpu/drm/bridge/lontium-lt9611uxd.c
@@ -0,0 +1,1387 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2025 LONTIUM
+ *
+ */
+#include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <drm/drm_drv.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_of.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include <sound/hdmi-codec.h>
+
+#define FW_SIZE 	(64 * 1024)
+#define LT_PAGE_SIZE 256
+#define FW_FILE  	"LT9611UXD.bin"
+
+struct lt9611uxd {
+	struct device *dev;
+	struct i2c_client *client;
+	struct drm_bridge bridge;
+	struct drm_connector connector;
+	struct regmap *regmap;
+	/* Protects all accesses to registers by stopping the on-chip MCU */
+	struct mutex ocm_lock;
+	struct work_struct work;
+	struct device_node *dsi0_node;
+	struct device_node *dsi2_node;
+	struct mipi_dsi_device *dsi0;
+	struct mipi_dsi_device *dsi2;
+	struct platform_device *audio_pdev;
+	struct gpio_desc *reset_gpio;
+	struct regulator_bulk_data supplies[2];
+	struct device *codec_dev;
+	struct task_struct *kthread;
+	hdmi_codec_plugged_cb plugged_cb;
+	const struct firmware *fw;
+	int fw_version;
+	u8 fw_crc;
+
+	bool hdmi_connected;
+	enum drm_connector_status audio_status;
+};
+
+#define LT9611C_PAGE_CONTROL	0xff
+
+static const struct regmap_range_cfg lt9611uxd_ranges[] = {
+	{
+		.name = "register_range",
+		.range_min =  0,
+		.range_max = 0xffff,
+		.selector_reg = LT9611C_PAGE_CONTROL,
+		.selector_mask = 0xff,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 0x100,
+	},
+};
+
+static const struct regmap_config lt9611uxd_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xffff,
+	.ranges = lt9611uxd_ranges,
+	.num_ranges = ARRAY_SIZE(lt9611uxd_ranges),
+};
+
+struct crc_info {
+	u8 width;
+	u32 poly;
+	u32 crc_init;
+	u32 xor_out;
+	bool refin;
+	bool refout;
+};
+
+static void lt9611uxd_audio_update_connector_status(struct lt9611uxd *lt9611uxd);
+
+static unsigned int bits_reverse(u32 in_val, u8 bits)
+{
+	u32 out_val = 0;
+	u8 i;
+
+	for (i = 0; i < bits; i++) {
+		if (in_val & (1 << i))
+			out_val |= 1 << (bits - 1 - i);
+	}
+
+	return out_val;
+}
+
+static unsigned int get_crc(struct crc_info type, const u8 *buf, u64 buf_len)
+{
+	u8 width = type.width;
+	u32 poly = type.poly;
+	u32 crc = type.crc_init;
+	u32 xorout = type.xor_out;
+	bool refin = type.refin;
+	bool refout = type.refout;
+	u8 n;
+	u32 bits;
+	u32 data;
+	u8 i;
+
+	n = (width < 8) ? 0 : (width - 8);
+	crc = (width < 8) ? (crc << (8 - width)) : crc;
+	bits = (width < 8) ? 0x80 : (1 << (width - 1));
+	poly = (width < 8) ? (poly << (8 - width)) : poly;
+	while (buf_len--) {
+		data = *(buf++);
+		if (refin)
+			data = bits_reverse(data, 8);
+		crc ^= (data << n);
+		for (i = 0; i < 8; i++) {
+			if (crc & bits)
+				crc = (crc << 1) ^ poly;
+			else
+				crc = crc << 1;
+		}
+	}
+	crc = (width < 8) ? (crc >> (8 - width)) : crc;
+	if (refout)
+		crc = bits_reverse(crc, width);
+	crc ^= xorout;
+
+	return (crc & ((2 << (width - 1)) - 1));
+}
+
+static u8 calculate_crc(struct lt9611uxd *lt9611uxd)
+{
+	struct crc_info type = {
+		.width = 8,
+		.poly = 0x31,
+		.crc_init = 0,
+		.xor_out = 0,
+		.refout = false,
+		.refin = false,
+	};
+	const u8 *upgrade_data;
+	u64 len;
+	u64 crc_size = FW_SIZE - 1;
+	u8 default_val = 0xff;
+
+	upgrade_data = lt9611uxd->fw->data;
+	len = lt9611uxd->fw->size;
+
+	type.crc_init = get_crc(type, upgrade_data, len);
+
+	crc_size -= len;
+	while (crc_size--)
+		type.crc_init = get_crc(type, &default_val, 1);
+
+	return type.crc_init;
+}
+
+static int i2c_read_write_flow(struct lt9611uxd *lt9611uxd, u8 *params,
+			       unsigned int param_count, u8 *return_buffer,
+			       unsigned int return_count)
+{
+	int count, i;
+	unsigned int temp;
+
+	regmap_write(lt9611uxd->regmap, 0xe0de, 0x01);
+
+	count = 0;
+	do {
+		regmap_read(lt9611uxd->regmap, 0xe0ae, &temp);
+		usleep_range(1000, 2000);
+		count++;
+	} while (count < 100 && temp != 0x01);
+
+	if (temp != 0x01)
+		return -1;
+
+	for (i = 0; i < param_count; i++) {
+		if (i > 0xdd - 0xb0)
+			break;
+
+		regmap_write(lt9611uxd->regmap, 0xe0b0 + i, params[i]);
+	}
+
+	regmap_write(lt9611uxd->regmap, 0xe0de, 0x02);
+
+	count = 0;
+	do {
+		regmap_read(lt9611uxd->regmap, 0xe0ae, &temp);
+		usleep_range(1000, 2000);
+		count++;
+	} while (count < 100 && temp != 0x02);
+
+	if (temp != 0x02)
+		return -2;
+
+	regmap_bulk_read(lt9611uxd->regmap, 0xe085, return_buffer, return_count);
+
+	return 0;
+}
+
+static int lt9611uxd_prepare_firmware_data(struct lt9611uxd *lt9611uxd)
+{
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+
+	/* ensure filesystem ready */
+	msleep(3000);
+	ret = request_firmware(&lt9611uxd->fw, FW_FILE, dev);
+	if (ret) {
+		dev_err(dev, "failed load file '%s', error type %d\n", FW_FILE, ret);
+		return ret;
+	}
+
+	if (lt9611uxd->fw->size > FW_SIZE - 1) {
+		dev_err(dev, "firmware too large (%zu > %d)\n", lt9611uxd->fw->size, FW_SIZE - 1);
+		lt9611uxd->fw = NULL;
+		return -EINVAL;
+	}
+
+	dev_info(dev, "firmware size: %zu bytes\n", lt9611uxd->fw->size);
+
+	lt9611uxd->fw_crc = calculate_crc(lt9611uxd);
+
+	dev_info(dev, "LT9611C.bin crc: 0x%02x\n", lt9611uxd->fw_crc);
+
+	return 0;
+}
+
+static void lt9611uxd_config_parameters(struct lt9611uxd *lt9611uxd)
+{
+	struct reg_sequence seq_write_paras[] = {
+		REG_SEQ0(0xe0ee, 0x01),
+		//fifo rst
+		REG_SEQ0(0xe103, 0x3f),
+		REG_SEQ0(0xe103, 0xff),
+
+		REG_SEQ0(0xe05e, 0xc1),
+		REG_SEQ0(0xe058, 0x00),
+		REG_SEQ0(0xe059, 0x50),
+		REG_SEQ0(0xe05a, 0x10),
+		REG_SEQ0(0xe05a, 0x00),
+		REG_SEQ0(0xe058, 0x21),
+	};
+
+	regmap_multi_reg_write(lt9611uxd->regmap, seq_write_paras, ARRAY_SIZE(seq_write_paras));
+}
+
+static void lt9611uxd_wren(struct lt9611uxd *lt9611uxd)
+{
+	regmap_write(lt9611uxd->regmap, 0xe05a, 0x04);
+	regmap_write(lt9611uxd->regmap, 0xe05a, 0x00);
+}
+
+static void lt9611uxd_wrdi(struct lt9611uxd *lt9611uxd)
+{
+	regmap_write(lt9611uxd->regmap, 0xe05a, 0x08);
+	regmap_write(lt9611uxd->regmap, 0xe05a, 0x00);
+}
+
+static void lt9611uxd_erase_op(struct lt9611uxd *lt9611uxd, u32 addr)
+{
+	struct reg_sequence seq_write[] = {
+		REG_SEQ0(0xe0ee, 0x01),
+		REG_SEQ0(0xe05a, 0x04),
+		REG_SEQ0(0xe05a, 0x00),
+		REG_SEQ0(0xe05b, (addr >> 16) & 0xff),
+		REG_SEQ0(0xe05c, (addr >> 8) & 0xff),
+		REG_SEQ0(0xe05d, addr & 0xff),
+		REG_SEQ0(0xe05a, 0x01),
+		REG_SEQ0(0xe05a, 0x00),
+	};
+
+	regmap_multi_reg_write(lt9611uxd->regmap, seq_write, ARRAY_SIZE(seq_write));
+}
+
+static void read_flash_reg_status(struct lt9611uxd *lt9611uxd, unsigned int *status)
+{
+	struct reg_sequence seq_write[] = {
+		REG_SEQ0(0xe103, 0x3f),
+		REG_SEQ0(0xe103, 0xff), //fifo rst
+
+		REG_SEQ0(0xe05e, 0x40),
+		REG_SEQ0(0xe056, 0x05),
+		REG_SEQ0(0xe055, 0x25),
+		REG_SEQ0(0xe055, 0x01),
+		REG_SEQ0(0xe058, 0x21),
+	};
+
+	regmap_multi_reg_write(lt9611uxd->regmap, seq_write, ARRAY_SIZE(seq_write));
+
+	regmap_read(lt9611uxd->regmap, 0xe05f, status);
+}
+
+static void lt9611uxd_crc_to_sram(struct lt9611uxd *lt9611uxd)
+{
+	struct reg_sequence seq_write[] = {
+		REG_SEQ0(0xe051, 0x00),
+		REG_SEQ0(0xe055, 0xc0),
+		REG_SEQ0(0xe055, 0x80),
+		REG_SEQ0(0xe05e, 0xc0),
+		REG_SEQ0(0xe058, 0x21),
+	};
+
+	regmap_multi_reg_write(lt9611uxd->regmap, seq_write, ARRAY_SIZE(seq_write));
+}
+
+static void lt9611uxd_data_to_sram(struct lt9611uxd *lt9611uxd)
+{
+	struct reg_sequence seq_write[] = {
+		REG_SEQ0(0xe051, 0xff),
+		REG_SEQ0(0xe055, 0x80),
+		REG_SEQ0(0xe05e, 0xc0),
+		REG_SEQ0(0xe058, 0x21),
+	};
+
+	regmap_multi_reg_write(lt9611uxd->regmap, seq_write, ARRAY_SIZE(seq_write));
+}
+
+static void lt9611uxd_sram_to_flash(struct lt9611uxd *lt9611uxd, u64 addr)
+{
+	struct reg_sequence seq_write[] = {
+		REG_SEQ0(0xe05b, (addr >> 16) & 0xff),
+		REG_SEQ0(0xe05c, (addr >> 8) & 0xff),
+		REG_SEQ0(0xe05d, addr & 0xff),
+		REG_SEQ0(0xe05a, 0x30),
+		REG_SEQ0(0xe05a, 0x00),
+	};
+
+	regmap_multi_reg_write(lt9611uxd->regmap, seq_write, ARRAY_SIZE(seq_write));
+}
+
+static void lt9611uxd_block_erase(struct lt9611uxd *lt9611uxd)
+{
+	struct device *dev = lt9611uxd->dev;
+	u32 i = 0;
+	unsigned int flash_status = 0;
+	unsigned int block_num = 0x00;
+	u32 flash_addr = 0x00;
+
+	for (block_num = 0; block_num < 2; block_num++) {
+		flash_addr = (block_num * 0x008000);
+		lt9611uxd_erase_op(lt9611uxd, flash_addr);
+		msleep(100);
+		i = 0;
+		while (1) {
+			read_flash_reg_status(lt9611uxd, &flash_status);
+			if ((flash_status & 0x01) == 0)
+				break;
+
+			if (i > 50)
+				break;
+
+			i++;
+			msleep(50);
+		}
+	}
+
+	dev_info(dev, "erase flash done.\n");
+}
+
+static int lt9611uxd_write_data(struct lt9611uxd *lt9611uxd, u64 addr)
+{
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+	int page = 0, num = 0, i = 0;
+	u64 size, index;
+	const u8 *data;
+	unsigned int value;
+
+	data = lt9611uxd->fw->data;
+	size = lt9611uxd->fw->size;
+	page = (size + LT_PAGE_SIZE - 1) / LT_PAGE_SIZE;
+	if (page * LT_PAGE_SIZE > FW_SIZE) {
+		dev_err(dev, "firmware size out of range\n");
+		return -EINVAL;
+	}
+
+	dev_info(dev, "%u pages, total size %llu byte\n", page, size);
+
+	for (num = 0; num < page; num++) {
+		lt9611uxd_data_to_sram(lt9611uxd);
+
+		for (i = 0; i < LT_PAGE_SIZE; i++) {
+			index = num * LT_PAGE_SIZE + i;
+			value = (index < size) ? data[index] : 0xff;
+
+			ret = regmap_write(lt9611uxd->regmap, 0xe059, value);
+			if (ret < 0) {
+				dev_err(dev, "write error at page %u, index %u\n", num, i);
+				return ret;
+			}
+		}
+
+		lt9611uxd_wren(lt9611uxd);
+		lt9611uxd_sram_to_flash(lt9611uxd, addr);
+
+		addr += LT_PAGE_SIZE;
+	}
+
+	lt9611uxd_wrdi(lt9611uxd);
+
+	return 0;
+}
+
+static int lt9611uxd_write_crc(struct lt9611uxd *lt9611uxd, u64 addr)
+{
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+	u8 crc;
+
+	crc = lt9611uxd->fw_crc;
+	lt9611uxd_crc_to_sram(lt9611uxd);
+	ret = regmap_write(lt9611uxd->regmap, 0xe059, crc);
+	if (ret < 0) {
+		dev_err(dev, "failed to write CRC\n");
+		return -1;
+	}
+
+	lt9611uxd_wren(lt9611uxd);
+	lt9611uxd_sram_to_flash(lt9611uxd, addr);
+	lt9611uxd_wrdi(lt9611uxd);
+
+	dev_info(dev, "CRC 0x%02x written to flash at addr 0x%llx\n", crc, addr);
+
+	return 0;
+}
+
+static int lt9611uxd_firmware_upgrade(struct lt9611uxd *lt9611uxd)
+{
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+
+	dev_info(dev, "starting firmware upgrade, size: %zu bytes\n", lt9611uxd->fw->size);
+
+	lt9611uxd_config_parameters(lt9611uxd);
+	lt9611uxd_block_erase(lt9611uxd);
+
+	ret = lt9611uxd_write_data(lt9611uxd, 0);
+	if (ret < 0) {
+		dev_err(dev, "Failed to write firmware data\n");
+		return ret;
+	}
+
+	ret = lt9611uxd_write_crc(lt9611uxd, FW_SIZE - 1);
+	if (ret < 0) {
+		dev_err(dev, "Failed to write firmware CRC\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int lt9611uxd_upgrade_result(struct lt9611uxd *lt9611uxd)
+{
+	struct device *dev = lt9611uxd->dev;
+	unsigned int crc_result;
+
+	regmap_write(lt9611uxd->regmap, 0xe0ee, 0x01);
+	regmap_read(lt9611uxd->regmap, 0xe021, &crc_result);
+
+	if (crc_result != lt9611uxd->fw_crc) {
+		dev_err(dev, "LT9611C firmware upgrade failed, expected CRC=0x%02X, read CRC=0x%02X\n",
+			lt9611uxd->fw_crc, crc_result);
+		return -EIO;
+	}
+
+	dev_info(dev, "LT9611C firmware upgrade success, CRC=0x%02x\n", crc_result);
+	return 0;
+}
+
+static struct lt9611uxd *connector_to_lt9611uxd(struct drm_connector *connector)
+{
+	return container_of(connector, struct lt9611uxd, connector);
+}
+
+static struct lt9611uxd *bridge_to_lt9611uxd(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct lt9611uxd, bridge);
+}
+
+static void lt9611uxd_lock(struct lt9611uxd *lt9611uxd)
+{
+	mutex_lock(&lt9611uxd->ocm_lock);
+	regmap_write(lt9611uxd->regmap, 0xe0ee, 0x01);
+}
+
+static void lt9611uxd_unlock(struct lt9611uxd *lt9611uxd)
+{
+	regmap_write(lt9611uxd->regmap, 0xe0ee, 0x00);
+	mutex_unlock(&lt9611uxd->ocm_lock);
+}
+
+static irqreturn_t lt9611uxd_irq_thread_handler(int irq, void *dev_id)
+{
+	struct lt9611uxd *lt9611uxd = dev_id;
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+	unsigned int irq_status;
+	u8 cmd[5] = {0x52, 0x48, 0x31, 0x3a, 0x00};
+	u8 data[5];
+
+	regmap_read(lt9611uxd->regmap, 0xe084, &irq_status);
+	if (!(irq_status & BIT(0)))
+		return IRQ_HANDLED;
+
+	mutex_lock(&lt9611uxd->ocm_lock);
+
+	ret = i2c_read_write_flow(lt9611uxd, cmd, 5, data, 5);
+	if (ret) {
+		dev_err(dev, "failed to read HPD status\n");
+	} else {
+		lt9611uxd->hdmi_connected = (data[4] == 0x02);
+		dev_info(dev, "HDMI %s\n", lt9611uxd->hdmi_connected ? "connected" : "disconnected");
+	}
+
+	lt9611uxd->audio_status = lt9611uxd->hdmi_connected ?
+			connector_status_connected :
+			connector_status_disconnected;
+
+	schedule_work(&lt9611uxd->work);
+
+	/*clear interrupt*/
+	regmap_write(lt9611uxd->regmap, 0xe0df, irq_status & BIT(0));
+	usleep_range(10000, 12000);
+	regmap_write(lt9611uxd->regmap, 0xe0df, irq_status & (~BIT(0)));
+
+	mutex_unlock(&lt9611uxd->ocm_lock);
+
+	return IRQ_HANDLED;
+}
+
+static void lt9611uxd_hpd_work(struct work_struct *work)
+{
+	struct lt9611uxd *lt9611uxd = container_of(work, struct lt9611uxd, work);
+	bool connected;
+
+	mutex_lock(&lt9611uxd->ocm_lock);
+	connected = lt9611uxd->hdmi_connected;
+	mutex_unlock(&lt9611uxd->ocm_lock);
+
+	drm_bridge_hpd_notify(&lt9611uxd->bridge, connected ?
+			      connector_status_connected :
+			      connector_status_disconnected);
+
+	usleep_range(300, 500);
+	lt9611uxd_audio_update_connector_status(lt9611uxd);
+}
+
+static void lt9611uxd_reset(struct lt9611uxd *lt9611uxd)
+{
+/*	gpiod_set_value_cansleep(lt9611uxd->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(lt9611uxd->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(lt9611uxd->reset_gpio, 1);
+	msleep(400);
+*/
+	msleep(2000);
+}
+
+static int lt9611uxd_regulator_init(struct lt9611uxd *lt9611uxd)
+{
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+
+	lt9611uxd->supplies[0].supply = "vcc";
+	lt9611uxd->supplies[1].supply = "vdd";
+
+	ret = devm_regulator_bulk_get(dev, 2, lt9611uxd->supplies);
+
+	return ret;
+}
+
+static int lt9611uxd_regulator_enable(struct lt9611uxd *lt9611uxd)
+{
+	int ret;
+
+	ret = regulator_enable(lt9611uxd->supplies[0].consumer);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(5000, 10000);
+
+	ret = regulator_enable(lt9611uxd->supplies[1].consumer);
+	if (ret < 0) {
+		regulator_disable(lt9611uxd->supplies[0].consumer);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int lt9611uxd_regulator_disable(struct lt9611uxd *lt9611uxd)
+{
+	int ret;
+
+	ret = regulator_disable(lt9611uxd->supplies[0].consumer);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(5000, 10000);
+
+	ret = regulator_disable(lt9611uxd->supplies[1].consumer);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct mipi_dsi_device *lt9611uxd_attach_dsi(struct lt9611uxd *lt9611uxd,
+						  struct device_node *dsi_node)
+{
+	const struct mipi_dsi_device_info info = { "lt9611uxd", 0, NULL };
+	struct mipi_dsi_device *dsi;
+	struct mipi_dsi_host *host;
+	struct device *dev = lt9611uxd->dev;
+	int ret;
+
+	host = of_find_mipi_dsi_host_by_node(dsi_node);
+	if (!host)
+		return ERR_PTR(dev_err_probe(dev, -EPROBE_DEFER, "failed to find dsi host\n"));
+
+	dsi = devm_mipi_dsi_device_register_full(dev, host, &info);
+	if (IS_ERR(dsi)) {
+		dev_err(dev, "failed to create dsi device\n");
+		return dsi;
+	}
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			 MIPI_DSI_MODE_VIDEO_HSE;
+
+	ret = devm_mipi_dsi_attach(dev, dsi);
+	if (ret < 0) {
+		dev_err(dev, "failed to attach dsi to host\n");
+		return ERR_PTR(ret);
+	}
+
+	return dsi;
+}
+
+static int lt9611uxd_connector_get_modes(struct drm_connector *connector)
+{
+	struct lt9611uxd *lt9611uxd = connector_to_lt9611uxd(connector);
+	const struct drm_edid *drm_edid;
+	int count;
+
+	drm_edid = drm_bridge_edid_read(&lt9611uxd->bridge, connector);
+	drm_edid_connector_update(connector, drm_edid);
+	count = drm_edid_connector_add_modes(connector);
+	drm_edid_free(drm_edid);
+
+	return count;
+}
+
+static enum drm_mode_status lt9611uxd_connector_mode_valid(struct drm_connector *connector,
+							 struct drm_display_mode *mode)
+{
+	u32 Pixclk;
+
+	Pixclk = (mode->htotal * mode->vtotal * drm_mode_vrefresh(mode))/1000000;
+
+	if((Pixclk >= 25) && (Pixclk <= 600))
+		return MODE_OK;
+ 	else
+		return MODE_BAD;
+}
+
+static enum drm_connector_status lt9611uxd_connector_detect(struct drm_connector *connector,
+							 bool force)
+{
+	struct lt9611uxd *lt9611uxd = connector_to_lt9611uxd(connector);
+
+	return lt9611uxd->bridge.funcs->detect(&lt9611uxd->bridge);
+}
+
+static const struct drm_connector_helper_funcs lt9611uxd_bridge_connector_helper_funcs = {
+	.get_modes = lt9611uxd_connector_get_modes,
+	.mode_valid = lt9611uxd_connector_mode_valid,
+};
+
+static const struct drm_connector_funcs lt9611uxd_bridge_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = lt9611uxd_connector_detect,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int lt9611uxd_connector_init(struct drm_bridge *bridge, struct lt9611uxd *lt9611uxd)
+{
+	int ret;
+
+	if (!bridge->encoder) {
+		DRM_ERROR("lt9611uxd Parent encoder object not found");
+		return -ENODEV;
+	}
+
+	lt9611uxd->connector.polled = DRM_CONNECTOR_POLL_HPD;
+
+	drm_connector_helper_add(&lt9611uxd->connector,
+				 &lt9611uxd_bridge_connector_helper_funcs);
+	ret = drm_connector_init(bridge->dev, &lt9611uxd->connector,
+				 &lt9611uxd_bridge_connector_funcs,
+				 DRM_MODE_CONNECTOR_HDMIA);
+	if (ret) {
+		DRM_ERROR("lt9611uxd failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	return drm_connector_attach_encoder(&lt9611uxd->connector, bridge->encoder);
+}
+
+
+static int lt9611uxd_bridge_attach(struct drm_bridge *bridge,
+				 enum drm_bridge_attach_flags flags)
+{
+	struct lt9611uxd *lt9611uxd = bridge_to_lt9611uxd(bridge);
+	int ret;
+
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
+		ret = lt9611uxd_connector_init(bridge, lt9611uxd);
+		if (ret < 0)
+			return ret;
+	}
+	
+	return 0;
+}
+
+static enum drm_mode_status lt9611uxd_bridge_mode_valid(struct drm_bridge *bridge,
+						      const struct drm_display_info *info,
+						      const struct drm_display_mode *mode)
+{
+	u32 pixclk;
+
+	pixclk = (mode->htotal * mode->vtotal * drm_mode_vrefresh(mode)) / 1000000;
+
+	if (pixclk >= 25 && pixclk <= 600)
+		return MODE_OK;
+	else
+		return MODE_BAD;
+}
+
+static void lt9611uxd_bridge_mode_set(struct drm_bridge *bridge,
+				    const struct drm_display_mode *mode,
+				    const struct drm_display_mode *adj_mode)
+{
+	int ret;
+	struct lt9611uxd *lt9611uxd = bridge_to_lt9611uxd(bridge);
+	u32 h_total, hactive, hsync_len, hfront_porch, hback_porch;
+	u32 v_total, vactive, vsync_len, vfront_porch, vback_porch;
+	u8 video_timing_set_cmd[26] = {0x57, 0x4d, 0x33, 0x3a};
+	u8 return_timing_set_param[3];
+	u8 framerate;
+	u8 vic = 0x00;
+
+	h_total = mode->htotal;
+	hactive = mode->hdisplay;
+	hsync_len = mode->hsync_end - mode->hsync_start;
+	hfront_porch = mode->hsync_start - mode->hdisplay;
+	hback_porch = mode->htotal - mode->hsync_end;
+
+	v_total = mode->vtotal;
+	vactive = mode->vdisplay;
+	vsync_len = mode->vsync_end - mode->vsync_start;
+	vfront_porch = mode->vsync_start - mode->vdisplay;
+	vback_porch = mode->vtotal - mode->vsync_end;
+	framerate = drm_mode_vrefresh(mode);
+	vic = drm_match_cea_mode(mode);
+
+	dev_info(lt9611uxd->dev, "hactive=%d, vactive=%d\n", hactive, vactive);
+	dev_info(lt9611uxd->dev, "framerate=%d\n", framerate);
+	dev_info(lt9611uxd->dev, "vic = 0x%02x\n", vic);
+
+	video_timing_set_cmd[4] = (h_total >> 8) & 0xff;
+	video_timing_set_cmd[5] = h_total & 0xff;
+	video_timing_set_cmd[6] = (hactive >> 8) & 0xff;
+	video_timing_set_cmd[7] = hactive & 0xff;
+	video_timing_set_cmd[8] = (hfront_porch >> 8) & 0xff;
+	video_timing_set_cmd[9] = hfront_porch & 0xff;
+	video_timing_set_cmd[10] = (hsync_len >> 8) & 0xff;
+	video_timing_set_cmd[11] = hsync_len & 0xff;
+	video_timing_set_cmd[12] = (hback_porch >> 8) & 0xff;
+	video_timing_set_cmd[13] = hback_porch & 0xff;
+	video_timing_set_cmd[14] = (v_total >> 8) & 0xff;
+	video_timing_set_cmd[15] = v_total & 0xff;
+	video_timing_set_cmd[16] = (vactive >> 8) & 0xff;
+	video_timing_set_cmd[17] = vactive & 0xFF;
+	video_timing_set_cmd[18] = (vfront_porch >> 8) & 0xff;
+	video_timing_set_cmd[19] = vfront_porch & 0xff;
+	video_timing_set_cmd[20] = (vsync_len >> 8) & 0xff;
+	video_timing_set_cmd[21] = vsync_len & 0xff;
+	video_timing_set_cmd[22] = (vback_porch >> 8) & 0xff;
+	video_timing_set_cmd[23] = vback_porch & 0xff;
+	video_timing_set_cmd[24] = framerate;
+	video_timing_set_cmd[25] = vic;
+
+	mutex_lock(&lt9611uxd->ocm_lock);
+	ret = i2c_read_write_flow(lt9611uxd, video_timing_set_cmd, 26, return_timing_set_param, 3);
+	if (ret)
+		dev_err(lt9611uxd->dev, "video set failed\n");
+	mutex_unlock(&lt9611uxd->ocm_lock);
+}
+
+static enum drm_connector_status lt9611uxd_bridge_detect(struct drm_bridge *bridge)
+{
+	int ret;
+	struct lt9611uxd *lt9611uxd = bridge_to_lt9611uxd(bridge);
+	bool connected = false;
+	u8 cmd[5] = {0x52, 0x48, 0x31, 0x3a, 0x00};
+	u8 data[5];
+
+	mutex_lock(&lt9611uxd->ocm_lock);
+	ret = i2c_read_write_flow(lt9611uxd, cmd, 5, data, 5);
+	if (ret)
+		dev_err(lt9611uxd->dev, "Failed to read HPD status (err=%d)\n", ret);
+	else
+		connected = (data[4] == 0x02);
+
+	lt9611uxd->hdmi_connected = connected;
+	if (connected)
+		lt9611uxd->audio_status = connector_status_connected;
+	else
+		lt9611uxd->audio_status = connector_status_disconnected;
+
+	mutex_unlock(&lt9611uxd->ocm_lock);
+
+	return connected ? connector_status_connected :
+				connector_status_disconnected;
+}
+
+static int lt9611uxd_get_edid_block(void *data, u8 *buf,
+				  unsigned int block, size_t len)
+{
+	struct lt9611uxd *lt9611uxd = data;
+	struct device *dev = lt9611uxd->dev;
+	u8 cmd[5] = {0x52, 0x48, 0x33, 0x3a, 0x00};
+	u8 packet[37];
+	int ret, i, offset = 0;
+
+	if (len != 128)
+		return -EINVAL;
+
+	for (i = 0; i < 4; i++) {
+		cmd[4] = block * 4 + i;
+		ret = i2c_read_write_flow(lt9611uxd, cmd, sizeof(cmd),
+					  packet, sizeof(packet));
+		if (ret) {
+			dev_err(dev, "Failed to read EDID block %u packet %d\n",
+				block, i);
+			return ret;
+		}
+
+		memcpy(buf + offset, &packet[5], 32);
+		offset += 32;
+	}
+
+	return 0;
+}
+
+static const struct drm_edid *lt9611uxd_bridge_edid_read(struct drm_bridge *bridge,
+						       struct drm_connector *connector)
+{
+	struct lt9611uxd *lt9611uxd = bridge_to_lt9611uxd(bridge);
+
+	return drm_edid_read_custom(connector, lt9611uxd_get_edid_block, lt9611uxd);
+}
+
+static const struct drm_bridge_funcs lt9611uxd_bridge_funcs = {
+	.attach = lt9611uxd_bridge_attach,
+	.mode_valid = lt9611uxd_bridge_mode_valid,
+	.mode_set = lt9611uxd_bridge_mode_set,
+	.detect = lt9611uxd_bridge_detect,
+	.edid_read = lt9611uxd_bridge_edid_read,
+};
+
+static int lt9611uxd_parse_dt(struct device *dev,
+			    struct lt9611uxd *lt9611uxd)
+{
+	lt9611uxd->dsi0_node = of_graph_get_remote_node(dev->of_node, 0, -1);
+	if (!lt9611uxd->dsi0_node) {
+		dev_err(dev, "failed to get remote node for primary dsi\n");
+		return -ENODEV;
+	}
+
+	lt9611uxd->dsi2_node = of_graph_get_remote_node(dev->of_node, 1, -1);
+
+	return 0;
+}
+
+static int lt9611uxd_gpio_init(struct lt9611uxd *lt9611uxd)
+{
+/*	struct device *dev = lt9611uxd->dev;
+
+	lt9611uxd->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(lt9611uxd->reset_gpio)) {
+		dev_err(dev, "failed to acquire reset gpio\n");
+		return PTR_ERR(lt9611uxd->reset_gpio);
+	}
+*/
+	return 0;
+}
+
+static int lt9611uxd_read_version(struct lt9611uxd *lt9611uxd)
+{
+	u8 buf[2];
+	int ret;
+
+	ret = regmap_write(lt9611uxd->regmap, 0xe0ee, 0x01);
+	if (ret)
+		return ret;
+
+	ret = regmap_bulk_read(lt9611uxd->regmap, 0xe080, buf, 2);
+	if (ret)
+		return ret;
+
+	return (buf[0] << 8) | buf[1];
+}
+
+static int lt9611uxd_read_chipid(struct lt9611uxd *lt9611uxd)
+{
+	struct device *dev = lt9611uxd->dev;
+	u8 chipid[2];
+	int ret;
+
+	ret = regmap_write(lt9611uxd->regmap, 0xe0ee, 0x01);
+	if (ret) {
+		dev_err(dev, "Failed to write unlock register: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_bulk_read(lt9611uxd->regmap, 0xe100, chipid, 2);
+	if (ret) {
+		dev_err(dev, "Failed to read chip ID: %d\n", ret);
+		return ret;
+	}
+
+	if (chipid[0] != 0x23 || chipid[1] != 0x06) {
+		dev_err(dev, "ChipID: 0x%02x 0x%02x\n", chipid[0], chipid[1]);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int lt9611uxd_hdmi_hw_params(struct device *dev, void *data,
+				  struct hdmi_codec_daifmt *fmt,
+				 struct hdmi_codec_params *hparms)
+{
+	struct lt9611uxd *lt9611uxd = dev_get_drvdata(dev);
+
+	dev_info(lt9611uxd->dev, "SOC sample_rate: %d, sample_width: %d, fmt: %d\n",
+		  hparms->sample_rate, hparms->sample_width, fmt->fmt);
+
+	switch (hparms->sample_rate) {
+	case 32000:
+	case 44100:
+	case 48000:
+	case 88200:
+	case 96000:
+	case 176400:
+	case 192000:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (hparms->sample_width) {
+	case 16:
+	case 18:
+	case 20:
+	case 24:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt->fmt) {
+	case HDMI_I2S:
+	case HDMI_SPDIF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void lt9611uxd_audio_shutdown(struct device *dev, void *data)
+{
+}
+
+static int lt9611uxd_audio_startup(struct device *dev, void *data)
+{
+	return 0;
+}
+
+static void lt9611uxd_audio_update_connector_status(struct lt9611uxd *lt9611uxd)
+{
+	enum drm_connector_status status;
+
+	status = lt9611uxd->audio_status;
+	if (lt9611uxd->plugged_cb && lt9611uxd->codec_dev)
+		lt9611uxd->plugged_cb(lt9611uxd->codec_dev,
+				 status == connector_status_connected);
+}
+
+static int lt9611uxd_hdmi_audio_hook_plugged_cb(struct device *dev,
+					      void *data,
+					 hdmi_codec_plugged_cb fn,
+					 struct device *codec_dev)
+{
+	struct lt9611uxd *lt9611uxd = data;
+
+	lt9611uxd->plugged_cb = fn;
+	lt9611uxd->codec_dev = codec_dev;
+	lt9611uxd_audio_update_connector_status(lt9611uxd);
+
+	return 0;
+}
+
+static const struct hdmi_codec_ops lt9611uxd_codec_ops = {
+	.hw_params	= lt9611uxd_hdmi_hw_params,
+	.audio_shutdown = lt9611uxd_audio_shutdown,
+	.audio_startup = lt9611uxd_audio_startup,
+	.hook_plugged_cb = lt9611uxd_hdmi_audio_hook_plugged_cb,
+};
+
+static int lt9611uxd_audio_init(struct device *dev, struct lt9611uxd *lt9611uxd)
+{
+	struct hdmi_codec_pdata codec_data = {
+		.ops = &lt9611uxd_codec_ops,
+		.max_i2s_channels = 8,
+		.i2s = 1,
+		.data = lt9611uxd,
+	};
+
+	lt9611uxd->audio_pdev =
+		platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,
+					      PLATFORM_DEVID_AUTO,
+					 &codec_data, sizeof(codec_data));
+
+	return PTR_ERR_OR_ZERO(lt9611uxd->audio_pdev);
+}
+
+static void lt9611uxd_audio_exit(struct lt9611uxd *lt9611uxd)
+{
+	if (lt9611uxd->audio_pdev) {
+		platform_device_unregister(lt9611uxd->audio_pdev);
+		lt9611uxd->audio_pdev = NULL;
+	}
+}
+
+static ssize_t lt9611uxd_firmware_store(struct device *dev, struct device_attribute *attr,
+				      const char *buf, size_t len)
+{
+	struct lt9611uxd *lt9611uxd = dev_get_drvdata(dev);
+	int ret;
+
+	lt9611uxd_lock(lt9611uxd);
+	ret = lt9611uxd_prepare_firmware_data(lt9611uxd);
+	if (ret < 0) {
+		dev_err(dev, "Failed prepare firmware data: %d\n", ret);
+		goto out;
+	}
+
+	ret = lt9611uxd_firmware_upgrade(lt9611uxd);
+	if (ret < 0) {
+		dev_err(dev, "upgrade failure\n");
+		goto out;
+	}
+	lt9611uxd_reset(lt9611uxd);
+	ret = lt9611uxd_upgrade_result(lt9611uxd);
+	if (ret < 0)
+		goto out;
+
+out:
+	lt9611uxd_unlock(lt9611uxd);
+	lt9611uxd_reset(lt9611uxd);
+	if (lt9611uxd->fw) {
+		release_firmware(lt9611uxd->fw);
+		lt9611uxd->fw = NULL;
+	}
+
+	return ret < 0 ? ret : len;
+}
+
+static ssize_t lt9611uxd_firmware_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lt9611uxd *lt9611uxd = dev_get_drvdata(dev);
+
+	return sysfs_emit(buf, "0x%04x\n", lt9611uxd->fw_version);
+}
+
+static DEVICE_ATTR_RW(lt9611uxd_firmware);
+
+static struct attribute *lt9611uxd_attrs[] = {
+	&dev_attr_lt9611uxd_firmware.attr,
+	NULL,
+};
+
+static const struct attribute_group lt9611uxd_attr_group = {
+	.attrs = lt9611uxd_attrs,
+};
+
+static const struct attribute_group *lt9611uxd_attr_groups[] = {
+	&lt9611uxd_attr_group,
+	NULL,
+};
+
+static int lt9611uxd_main(void *data)
+{
+	struct lt9611uxd *lt9611uxd = data;
+	struct device *dev = lt9611uxd->dev;
+	struct i2c_client *client = lt9611uxd->client;
+	int ret;
+	bool fw_updated = false;
+
+	ret = lt9611uxd_parse_dt(dev, lt9611uxd);
+	if (ret) {
+		dev_err(dev, "failed to parse device tree\n");
+		return ret;
+	}
+
+	ret = lt9611uxd_gpio_init(lt9611uxd);
+	if (ret < 0)
+		goto err_of_put;
+
+	ret = lt9611uxd_regulator_init(lt9611uxd);
+	if (ret < 0)
+		goto err_of_put;
+
+	ret = lt9611uxd_regulator_enable(lt9611uxd);
+	if (ret)
+		goto err_of_put;
+
+	lt9611uxd_reset(lt9611uxd);
+
+	ret = lt9611uxd_read_chipid(lt9611uxd);
+	if (ret < 0) {
+		dev_err(dev, "failed to read chip id.\n");
+		goto err_disable_regulators;
+	}
+
+	lt9611uxd_lock(lt9611uxd);
+retry:
+	ret = lt9611uxd_read_version(lt9611uxd);
+	if (ret < 0) {
+		dev_err(dev, "failed to read FW version\n");
+		lt9611uxd_unlock(lt9611uxd);
+		goto err_disable_regulators;
+
+	} else if (ret == 0) { // Upgrade conditions
+		if (!fw_updated) {
+			fw_updated = true;
+			ret = lt9611uxd_prepare_firmware_data(lt9611uxd);
+			if (ret < 0) {
+				lt9611uxd_unlock(lt9611uxd);
+				goto err_disable_regulators;
+			}
+
+			ret = lt9611uxd_firmware_upgrade(lt9611uxd);
+			if (ret < 0) {
+				lt9611uxd_unlock(lt9611uxd);
+				goto err_disable_regulators;
+			}
+
+			lt9611uxd_reset(lt9611uxd);
+			ret = lt9611uxd_upgrade_result(lt9611uxd);
+			if (ret < 0) {
+				lt9611uxd_unlock(lt9611uxd);
+				goto err_disable_regulators;
+			} else {
+				goto retry;
+			}
+		} else {
+			dev_err(dev, "FW version 0x%04x, update failed\n", ret);
+			ret = -EOPNOTSUPP;
+			lt9611uxd_unlock(lt9611uxd);
+			goto err_disable_regulators;
+		}
+	}
+
+	if (lt9611uxd->fw) {
+		release_firmware(lt9611uxd->fw);
+		lt9611uxd->fw = NULL;
+	}
+	lt9611uxd_unlock(lt9611uxd);
+	lt9611uxd->fw_version = ret;
+
+	dev_info(dev, "current version:0x%04x", lt9611uxd->fw_version);
+
+	INIT_WORK(&lt9611uxd->work, lt9611uxd_hpd_work);
+
+	ret = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+					lt9611uxd_irq_thread_handler,
+					IRQF_TRIGGER_FALLING |
+					IRQF_ONESHOT |
+					IRQF_NO_AUTOEN,
+					"lt9611uxd", lt9611uxd);
+
+	if (ret) {
+		dev_err(dev, "failed to request irq\n");
+		goto err_disable_regulators;
+	}
+
+	lt9611uxd->bridge.funcs = &lt9611uxd_bridge_funcs;
+	lt9611uxd->bridge.of_node = lt9611uxd->client->dev.of_node;
+	lt9611uxd->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID | DRM_BRIDGE_OP_HPD;
+	lt9611uxd->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+
+	drm_bridge_add(&lt9611uxd->bridge);
+
+	// Attach primary DSI
+	lt9611uxd->dsi0 = lt9611uxd_attach_dsi(lt9611uxd, lt9611uxd->dsi0_node);
+	if (IS_ERR(lt9611uxd->dsi0)) {
+		ret = PTR_ERR(lt9611uxd->dsi0);
+		dev_err(dev, "Failed attach primary DSI\n");
+		goto err_remove_bridge;
+	}
+
+	// Attach secondary DSI, if specified
+	if (lt9611uxd->dsi2_node) {
+		lt9611uxd->dsi2 = lt9611uxd_attach_dsi(lt9611uxd, lt9611uxd->dsi2_node);
+		if (IS_ERR(lt9611uxd->dsi2)) {
+			ret = PTR_ERR(lt9611uxd->dsi2);
+			dev_err(dev, "Failed attach secondary DSI\n");
+			goto err_remove_bridge;
+		}
+	}
+
+	lt9611uxd->audio_status = connector_status_disconnected;
+
+	ret = lt9611uxd_audio_init(dev, lt9611uxd);
+	if (ret < 0) {
+		dev_err(dev, "audio init failed\n");
+		goto err_remove_bridge;
+	}
+
+	enable_irq(client->irq);
+	lt9611uxd_reset(lt9611uxd);
+
+	return 0;
+
+err_remove_bridge:
+	cancel_work_sync(&lt9611uxd->work);
+	drm_bridge_remove(&lt9611uxd->bridge);
+
+err_disable_regulators:
+	regulator_bulk_disable(ARRAY_SIZE(lt9611uxd->supplies), lt9611uxd->supplies);
+
+err_of_put:
+	of_node_put(lt9611uxd->dsi2_node);
+	of_node_put(lt9611uxd->dsi0_node);
+
+	if (lt9611uxd->fw) {
+		release_firmware(lt9611uxd->fw);
+		lt9611uxd->fw = NULL;
+	}
+
+	return ret;
+}
+
+static int lt9611uxd_probe(struct i2c_client *client)
+{
+	struct lt9611uxd *lt9611uxd;
+	struct device *dev = &client->dev;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(dev, "device doesn't support I2C\n");
+		return -ENODEV;
+	}
+
+	lt9611uxd = devm_kzalloc(dev, sizeof(*lt9611uxd), GFP_KERNEL);
+	if (!lt9611uxd)
+		return -ENOMEM;
+
+	lt9611uxd->dev = dev;
+	lt9611uxd->client = client;
+	mutex_init(&lt9611uxd->ocm_lock);
+
+	lt9611uxd->regmap = devm_regmap_init_i2c(client, &lt9611uxd_regmap_config);
+	if (IS_ERR(lt9611uxd->regmap)) {
+		dev_err(dev, "regmap i2c init failed\n");
+		return PTR_ERR(lt9611uxd->regmap);
+	}
+
+	i2c_set_clientdata(client, lt9611uxd);
+
+	//Use kthread to ensure that the firmware upgrade does
+	//not block the initialization of the file system.
+	lt9611uxd->kthread = kthread_run(lt9611uxd_main, lt9611uxd, "lt9611uxd");
+	if (IS_ERR(lt9611uxd->kthread)) {
+		dev_err(dev, "Failed to create kernel thread\n");
+		return PTR_ERR(lt9611uxd->kthread);
+	}
+
+	return 0;
+}
+
+static void lt9611uxd_remove(struct i2c_client *client)
+{
+	struct lt9611uxd *lt9611uxd = i2c_get_clientdata(client);
+
+	disable_irq(client->irq);
+	cancel_work_sync(&lt9611uxd->work);
+	lt9611uxd_audio_exit(lt9611uxd);
+	drm_bridge_remove(&lt9611uxd->bridge);
+	mutex_destroy(&lt9611uxd->ocm_lock);
+	regulator_bulk_disable(ARRAY_SIZE(lt9611uxd->supplies), lt9611uxd->supplies);
+	of_node_put(lt9611uxd->dsi2_node);
+	of_node_put(lt9611uxd->dsi0_node);
+}
+
+static int lt9611uxd_bridge_suspend(struct device *dev)
+{
+	struct lt9611uxd *lt9611uxd = dev_get_drvdata(dev);
+	int ret;
+
+	dev_info(lt9611uxd->dev, "suspend\n");
+	disable_irq(lt9611uxd->client->irq);
+	ret = lt9611uxd_regulator_disable(lt9611uxd);
+	gpiod_set_value_cansleep(lt9611uxd->reset_gpio, 0);
+
+	return ret;
+}
+
+static int lt9611uxd_bridge_resume(struct device *dev)
+{
+	struct lt9611uxd *lt9611uxd = dev_get_drvdata(dev);
+	int ret;
+
+	ret = lt9611uxd_regulator_enable(lt9611uxd);
+	lt9611uxd_reset(lt9611uxd);
+	enable_irq(lt9611uxd->client->irq);
+	dev_info(lt9611uxd->dev, "resume\n");
+
+	return ret;
+}
+
+static const struct dev_pm_ops lt9611uxd_bridge_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lt9611uxd_bridge_suspend,
+				lt9611uxd_bridge_resume)
+};
+
+static struct i2c_device_id lt9611uxd_id[] = {
+	{ "lontium,lt9611uxd", 0 },
+	{ /* sentinel */ }
+};
+
+static const struct of_device_id lt9611uxd_match_table[] = {
+	{ .compatible = "lontium,lt9611uxd" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, lt9611uxd_match_table);
+
+static struct i2c_driver lt9611uxd_driver = {
+	.driver = {
+		.name = "lt9611uxd",
+		.of_match_table = lt9611uxd_match_table,
+		.pm = &lt9611uxd_bridge_pm_ops,
+		.dev_groups = lt9611uxd_attr_groups,
+	},
+	.probe = lt9611uxd_probe,
+	.remove = lt9611uxd_remove,
+	.id_table = lt9611uxd_id,
+};
+module_i2c_driver(lt9611uxd_driver);
+
+MODULE_AUTHOR("sunyun yang <syyang@lontium.com>");
+MODULE_LICENSE("GPL v2");
+
+MODULE_FIRMWARE(FW_FILE);
