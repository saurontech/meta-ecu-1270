From 064e6741aa1b4e0db9222423304e0a57a5bbe90a Mon Sep 17 00:00:00 2001
From: Samuel Cheng <samuelogre@gmail.com>
Date: Thu, 2 Oct 2025 16:09:38 +0800
Subject: [PATCH 1/3] add driver support for cooling device

---
 drivers/thermal/k3_j72xx_bandgap.c | 119 +++++++++++++++++++++++++++++
 1 file changed, 119 insertions(+)

diff --git a/drivers/thermal/k3_j72xx_bandgap.c b/drivers/thermal/k3_j72xx_bandgap.c
index 0acafdfdd6f2..f4feab9389b1 100644
--- a/drivers/thermal/k3_j72xx_bandgap.c
+++ b/drivers/thermal/k3_j72xx_bandgap.c
@@ -19,6 +19,9 @@
 #include <linux/of.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/cpufreq.h>
+#include <linux/cpumask.h>
+#include <linux/cpu_cooling.h>
 
 #define K3_VTM_DEVINFO_PWR0_OFFSET		0x4
 #define K3_VTM_DEVINFO_PWR0_TEMPSENS_CT_MASK	0xf0
@@ -183,11 +186,24 @@ struct k3_j72xx_bandgap {
 
 /* common data structures */
 struct k3_thermal_data {
+	struct cpufreq_policy *policy;
 	struct k3_j72xx_bandgap *bgp;
+	struct thermal_zone_device *ti_thermal;
+	struct thermal_cooling_device *cool_dev;
+	struct work_struct thermal_wq;
+	int prev_temp;
 	u32 ctrl_offset;
 	u32 stat_offset;
 };
 
+static void k3_thermal_work(struct work_struct *work)
+{
+	struct k3_thermal_data *data = container_of(work,
+					struct k3_thermal_data, thermal_wq);
+
+	thermal_zone_device_update(data->ti_thermal, THERMAL_EVENT_UNSPECIFIED);
+}
+
 static int two_cmp(int tmp, int mask)
 {
 	tmp = ~(tmp);
@@ -252,8 +268,53 @@ static int k3_thermal_get_temp(struct thermal_zone_device *tz, int *temp)
 	return k3_bgp_read_temp(thermal_zone_device_priv(tz), temp);
 }
 
+static int k3_thermal_get_trend(void *p, int *trend)
+{
+	struct k3_thermal_data *data = p;
+	struct k3_j72xx_bandgap *bgp;
+	u32 temp1, temp2;
+	int ret = 0;
+
+	bgp = data->bgp;
+	if (!data->ti_thermal)
+		return -EINVAL;
+
+	ret = k3_thermal_get_temp(data->ti_thermal, &temp1);
+	if (ret)
+		return ret;
+	temp2 = data->prev_temp;
+
+	*trend = temp1 - temp2;
+
+	data->prev_temp = temp1;
+
+	return ret;
+}
+
+static int __k3_thermal_get_trend(struct thermal_zone_device *tz,
+				  const struct thermal_trip *trip,
+				  enum thermal_trend *trend)
+{
+	struct k3_thermal_data *data = thermal_zone_device_priv(tz);
+	int ret = 0, tr;
+
+	ret = k3_thermal_get_trend(data, &tr);
+	if (ret)
+		return ret;
+
+	if (tr > 0)
+		*trend = THERMAL_TREND_RAISING;
+	else if (tr < 0)
+		*trend = THERMAL_TREND_DROPPING;
+	else
+		*trend = THERMAL_TREND_STABLE;
+
+	return 0;
+}
+
 static const struct thermal_zone_device_ops k3_of_thermal_ops = {
 	.get_temp = k3_thermal_get_temp,
+	.get_trend = __k3_thermal_get_trend,
 };
 
 static int k3_j72xx_bandgap_temp_to_adc_code(int temp)
@@ -372,6 +433,61 @@ struct k3_j72xx_bandgap_data {
 	const bool has_errata_i2128;
 };
 
+static int k3_thermal_register_cpu_cooling(struct k3_j72xx_bandgap *bgp, int id)
+{
+	struct k3_thermal_data *data;
+	struct device_node *np = bgp->dev->of_node;
+
+	/*
+	 * We are assuming here that if one deploys the zone
+	 * using DT, then it must be aware that the cooling device
+	 * loading has to happen via cpufreq driver.
+	 */
+	if (of_property_present(np, "#thermal-sensor-cells"))
+		return 0;
+
+	data = bgp->ts_data[id];
+	if (!data)
+		return -EINVAL;
+
+	data->policy = cpufreq_cpu_get(0);
+	if (!data->policy) {
+		pr_debug("%s: CPUFreq policy not found\n", __func__);
+		return -EPROBE_DEFER;
+	}
+
+	/* Register cooling device */
+	data->cool_dev = cpufreq_cooling_register(data->policy);
+	if (IS_ERR(data->cool_dev)) {
+		int ret = PTR_ERR(data->cool_dev);
+
+		dev_err(bgp->dev, "Failed to register cpu cooling device %d\n",
+			ret);
+		cpufreq_cpu_put(data->policy);
+
+		return ret;
+	}
+
+	INIT_WORK(&data->thermal_wq, k3_thermal_work);
+
+	return 0;
+}
+
+static int ti_thermal_unregister_cpu_cooling(struct k3_j72xx_bandgap *bgp, int id)
+{
+	struct k3_thermal_data *data;
+
+	data = bgp->ts_data[id];
+
+	if (!IS_ERR_OR_NULL(data)) {
+		cpufreq_cooling_unregister(data->cool_dev);
+		if (data->policy)
+			cpufreq_cpu_put(data->policy);
+	}
+
+	return 0;
+}
+
 static int k3_j72xx_bandgap_probe(struct platform_device *pdev)
 {
 	const struct k3_j72xx_bandgap_data *driver_data;
@@ -506,6 +622,9 @@ static int k3_j72xx_bandgap_probe(struct platform_device *pdev)
 
 	/* Register the thermal sensors */
 	for (id = 0; id < bgp->cnt; id++) {
+		if (id == 0)
+			ret = k3_thermal_register_cpu_cooling(bgp, 0);
+
 		ti_thermal = devm_thermal_of_zone_register(bgp->dev, id, &data[id],
 							   &k3_of_thermal_ops);
 		if (IS_ERR(ti_thermal)) {
-- 
2.43.0

